{"version":3,"sources":["webpack:///./node_modules/three-fbxloader-offical/inflate.min.js","webpack:///./src/views/Animation.vue?90b8","webpack:///./src/views/Animation.vue?7048","webpack:///./src/views/Animation.vue?8506","webpack:///./src/views/Animation.vue","webpack:///./src/views/Animation.vue?71d1","webpack:///./node_modules/three-fbxloader-offical/index.js"],"names":["l","aa","this","r","c","d","e","a","split","b","execScript","length","shift","t","Uint8Array","Uint16Array","Uint32Array","DataView","v","f","g","h","k","m","n","p","s","x","Number","POSITIVE_INFINITY","Array","w","input","i","y","index","bufferSize","bufferType","resize","A","z","j","Error","B","prototype","C","set","subarray","ba","ca","D","S","T","U","u","M","F","q","V","E","slice","P","fa","G","H","I","J","K","L","da","ea","N","O","R","ga","Q","W","verify","ha","method","o","push","buffer","charCodeAt","Y","Z","$","ia","X","ADAPTIVE","BLOCK","Object","keys","call","Animationvue_type_template_id_34ae3e1f_render","_vm","_h","$createElement","_c","_self","staticClass","attrs","id","on","click","display","_v","directives","name","rawName","value","percentage","expression","text-inside","stroke-width","status","staticRenderFns","Animationvue_type_script_lang_ts_Geometry","_Vue","Geometry","_this","classCallCheck","inherits","createClass","key","AnimationAction","play","mixer","_this2","scene","three_module","loader","three_fbxloader_offical_default","load","obj","add","translateY","clipAction","animations","loop","clampWhenFinished","xhr","loaded","total","point","position","ambient","width","window","innerWidth","height","innerHeight","camera","lookAt","renderer","setSize","setClearColor","document","getElementById","render","requestAnimationFrame","rend","appendChild","domElement","clock","update","getDelta","OrbitControls","vue_property_decorator","tslib_es6","Animationvue_type_script_lang_ts_","views_Animationvue_type_script_lang_ts_","component","componentNormalizer","options","__file","__webpack_exports__","_node_modules_mini_css_extract_plugin_dist_loader_js_ref_10_oneOf_1_0_node_modules_css_loader_index_js_ref_10_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_10_oneOf_1_2_node_modules_less_loader_dist_cjs_js_ref_10_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_Animation_vue_vue_type_style_index_0_lang_less___WEBPACK_IMPORTED_MODULE_0__","__webpack_require__","_node_modules_mini_css_extract_plugin_dist_loader_js_ref_10_oneOf_1_0_node_modules_css_loader_index_js_ref_10_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_10_oneOf_1_2_node_modules_less_loader_dist_cjs_js_ref_10_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_Animation_vue_vue_type_style_index_0_lang_less___WEBPACK_IMPORTED_MODULE_0___default","THREE","Zlib","module","exports","parseConnections","FBXTree","connectionMap","Map","rawConnections","Connections","connections","forEach","rawConnection","fromID","toID","relationship","has","parents","children","parentRelationship","ID","get","childRelationship","parseImages","images","blobs","Objects","videoNodes","Video","nodeID","videoNode","parseInt","RelativeFilename","Filename","arrayBufferContent","Content","ArrayBuffer","byteLength","base64Content","image","parseImage","filename","undefined","pop","type","content","fileName","extension","lastIndexOf","toLowerCase","TGALoader","console","warn","Loader","Handlers","array","URL","createObjectURL","Blob","parseTextures","textureMap","textureNodes","Texture","texture","parseTexture","textureNode","loadTexture","attrName","wrapModeU","WrapModeU","wrapModeV","WrapModeV","valueU","valueV","wrapS","RepeatWrapping","ClampToEdgeWrapping","wrapT","values","Scaling","repeat","currentPath","path","indexOf","setPath","FileName","parseMaterials","materialMap","materialNodes","Material","material","parseMaterial","materialNode","ShadingModel","parameters","parseParameters","MeshPhongMaterial","MeshLambertMaterial","color","setValues","properties","BumpFactor","bumpScale","Diffuse","Color","fromArray","DiffuseColor","DisplacementFactor","displacementScale","Emissive","emissive","EmissiveColor","EmissiveFactor","emissiveIntensity","parseFloat","Opacity","opacity","transparent","ReflectionFactor","reflectivity","Shininess","shininess","Specular","specular","SpecularColor","child","bumpMap","map","getTexture","displacementMap","emissiveMap","normalMap","envMap","mapping","EquirectangularReflectionMapping","specularMap","alphaMap","LayeredTexture","parseDeformers","skeletons","morphTargets","DeformerNodes","Deformer","deformerNode","relationships","attrType","skeleton","parseSkeleton","geometryID","morphTarget","rawTargets","parseMorphTargets","parentGeoID","deformerNodes","rawBones","boneNode","rawBone","indices","weights","transform","Matrix4","Transform","transformLink","TransformLink","linkMode","Mode","Indexes","Weights","bones","rawMorphTargets","morphTargetNode","rawMorphTarget","initialWeight","DeformPercent","fullWeights","FullWeights","targetRelationships","weightCurveID","geoID","parseGeometries","deformers","geometryMap","geoNodes","geo","parseGeometry","geoNode","parseMeshGeometry","parseNurbsGeometry","modelNodes","parent","Model","reduce","preTransform","modelNode","GeometricRotation","Math","degToRad","makeRotationFromEuler","Euler","setPosition","Vector3","GeometricTranslation","scale","GeometricScaling","genGeometry","BufferGeometry","geoInfo","getGeoInfo","buffers","genBuffers","positionAttribute","Float32BufferAttribute","vertex","applyToBufferAttribute","addAttribute","colors","Uint16BufferAttribute","weightsIndices","vertexWeights","FBX_Deformer","normal","normalAttribute","normalMatrix","Matrix3","getNormalMatrix","uvs","uvBuffer","toString","mappingType","prevMaterialIndex","materialIndex","startIndex","currentIndex","addGroup","groups","lastGroup","lastIndex","start","count","addMorphTargets","vertexPositions","Vertices","vertexIndices","PolygonVertexIndex","LayerElementColor","getColors","LayerElementMaterial","getMaterials","LayerElementNormal","getNormals","LayerElementUV","uv","getUVs","weightTable","weight","polygonIndex","faceLength","displayedWeightsWarning","facePositionIndexes","faceNormals","faceColors","faceUVs","faceWeights","faceWeightIndices","vertexIndex","polygonVertexIndex","endOfFace","weightIndices","data","getData","wt","wIndex","Weight","weightIndex","currentWeight","comparedWeight","comparedWeightIndex","comparedWeightArray","tmp","genFace","parentGeo","parentGeoNode","morphAttributes","rawTarget","morphGeoNode","genMorphGeometry","morphGeo","morphPositions","morphIndex","morphGeoInfo","morphBuffers","NormalNode","MappingInformationType","referenceType","ReferenceInformationType","Normals","indexBuffer","NormalIndex","NormalsIndex","dataSize","UVNode","UV","UVIndex","ColorNode","Colors","ColorIndex","MaterialNode","materialIndexBuffer","Materials","materialIndices","FBXLoader","manager","DefaultLoadingManager","assign","url","onLoad","onProgress","onError","self","resourceDirectory","LoaderUtils","extractUrlBase","FileLoader","setResponseType","parse","error","setTimeout","itemError","FBXBuffer","isFbxFormatBinary","BinaryParser","FBXText","convertArrayBufferToString","isFbxFormatASCII","getFbxVersion","TextParser","textures","TextureLoader","materials","sceneGraph","parseScene","dataArray","infoObject","from","to","NURBSCurve","order","Order","isNaN","startKnot","endKnot","degree","knots","KnotVector","controlPoints","pointsValues","Points","Vector4","Form","curve","vertices","getPoints","positions","Float32Array","toArray","geometry","BufferAttribute","Group","modelMap","parseModels","model","setLookAtProperties","parentConnections","connection","bindSkeleton","addAnimations","createAmbientLight","node","buildSkeleton","createCamera","createLight","createMesh","createCurve","PropertyBinding","sanitizeNodeName","setModelTransforms","bone","subBone","Bone","matrixWorld","copy","cameraAttribute","attr","NodeAttribute","Object3D","CameraProjectionType","nearClippingPlane","NearPlane","farClippingPlane","FarPlane","AspectWidth","AspectHeight","aspect","fov","FieldOfView","focalLength","FocalLength","PerspectiveCamera","setFocalLength","OrthographicCamera","lightAttribute","LightType","intensity","Intensity","CastLightOnObject","distance","FarAttenuationEnd","EnableFarAttenuation","decay","PointLight","DirectionalLight","angle","PI","InnerAngle","penumbra","OuterAngle","max","SpotLight","CastShadows","castShadow","attributes","vertexColors","VertexColors","skinning","SkinnedMesh","Mesh","LineBasicMaterial","linewidth","Line","GlobalSettings","ambientColor","AmbientColor","AmbientLight","lookAtTarget","pos","Lcl_Translation","target","enums","RotationOrder","rotation","Lcl_Rotation","quaternion","setFromEuler","Lcl_Scaling","PreRotation","preRotations","Quaternion","premultiply","bindMatrices","parsePoseNodes","geoRelationships","geoConnParent","bind","Skeleton","BindPoseNode","Pose","poseNodes","PoseNode","isArray","poseNode","Node","Matrix","parseAnimations","AnimationCurve","curveNodesMap","parseAnimationCurveNodes","parseAnimationCurves","layersMap","parseAnimationLayers","rawClips","parseAnimStacks","rawCurveNodes","AnimationCurveNode","rawCurveNode","match","curveNode","curves","rawCurves","animationCurve","times","KeyTime","convertFBXTimeToSeconds","KeyValueFloat","animationCurveID","animationCurveRelationship","rawLayers","AnimationLayer","layerCurveNodes","modelID","rawModel","modelName","initialPosition","initialRotation","initialScale","rawStacks","AnimationStack","layer","rawClip","clip","addClip","tracks","rawTracks","concat","generateTracks","AnimationClip","positionTrack","generateVectorTrack","rotationTrack","generateRotationTrack","scaleTrack","initialValue","getTimesForAllAxes","getKeyframeTrackValues","VectorKeyframeTrack","interpolateRotations","euler","quaternionValues","QuaternionKeyframeTrack","prevValue","xIndex","yIndex","zIndex","time","xValue","yValue","zValue","sort","filter","elem","valuesSpan","absoluteSpan","abs","numSubIntervals","step","nextValue","initialTime","timeSpan","interval","nextTime","interpolatedTimes","interpolatedValues","inject","BinaryReader","littleEndian","dv","offset","CORRECT","text","cursor","read","result","num","versionRegExp","version","parseNumberArray","val","decodeText","append","a1","a2","getPrevNode","nodeStack","currentIndent","getCurrentNode","getCurrentProp","currentProp","pushStack","popStack","setCurrentProp","currentPropName","allNodes","line","matchComment","matchEmpty","matchBeginning","matchProperty","matchEnd","parseNodeBegin","parseNodeProperty","parseNodePropertyContinued","property","nodeName","trim","replace","nodeAttrs","parseNodeAttr","currentNode","contentLine","propName","propValue","parentName","connProps","rest","parseNodeSpecialProperty","props","prop","innerPropName","innerPropType1","innerPropType2","innerPropFlag","innerPropValue","type2","flag","reader","skip","getUint32","log","endOfContent","parseNode","size","getOffset","endOffset","getUint64","numProperties","nameLen","getUint8","getString","propertyList","parseProperty","singleProperty","subNode","parseSubNode","getBoolean","getFloat64","getFloat32","getInt32","getInt64","getArrayBuffer","getInt16","arrayLength","encoding","compressedLength","getBooleanArray","getFloat64Array","getFloat32Array","getInt32Array","getInt64Array","inflate","Inflate","reader2","decompress","low","high","nullByte"],"mappings":"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","file":"js/Animation.bda11554.js","sourcesContent":["/** @license zlib.js 2012 - imaya [ https://github.com/imaya/zlib.js ] The MIT License */(function() {'use strict';var l=void 0,aa=this;function r(c,d){var a=c.split(\".\"),b=aa;!(a[0]in b)&&b.execScript&&b.execScript(\"var \"+a[0]);for(var e;a.length&&(e=a.shift());)!a.length&&d!==l?b[e]=d:b=b[e]?b[e]:b[e]={}};var t=\"undefined\"!==typeof Uint8Array&&\"undefined\"!==typeof Uint16Array&&\"undefined\"!==typeof Uint32Array&&\"undefined\"!==typeof DataView;function v(c){var d=c.length,a=0,b=Number.POSITIVE_INFINITY,e,f,g,h,k,m,n,p,s,x;for(p=0;p<d;++p)c[p]>a&&(a=c[p]),c[p]<b&&(b=c[p]);e=1<<a;f=new (t?Uint32Array:Array)(e);g=1;h=0;for(k=2;g<=a;){for(p=0;p<d;++p)if(c[p]===g){m=0;n=h;for(s=0;s<g;++s)m=m<<1|n&1,n>>=1;x=g<<16|p;for(s=m;s<e;s+=k)f[s]=x;++h}++g;h<<=1;k<<=1}return[f,a,b]};function w(c,d){this.g=[];this.h=32768;this.d=this.f=this.a=this.l=0;this.input=t?new Uint8Array(c):c;this.m=!1;this.i=y;this.r=!1;if(d||!(d={}))d.index&&(this.a=d.index),d.bufferSize&&(this.h=d.bufferSize),d.bufferType&&(this.i=d.bufferType),d.resize&&(this.r=d.resize);switch(this.i){case A:this.b=32768;this.c=new (t?Uint8Array:Array)(32768+this.h+258);break;case y:this.b=0;this.c=new (t?Uint8Array:Array)(this.h);this.e=this.z;this.n=this.v;this.j=this.w;break;default:throw Error(\"invalid inflate mode\");\r\n}}var A=0,y=1,B={t:A,s:y};\r\nw.prototype.k=function(){for(;!this.m;){var c=C(this,3);c&1&&(this.m=!0);c>>>=1;switch(c){case 0:var d=this.input,a=this.a,b=this.c,e=this.b,f=d.length,g=l,h=l,k=b.length,m=l;this.d=this.f=0;if(a+1>=f)throw Error(\"invalid uncompressed block header: LEN\");g=d[a++]|d[a++]<<8;if(a+1>=f)throw Error(\"invalid uncompressed block header: NLEN\");h=d[a++]|d[a++]<<8;if(g===~h)throw Error(\"invalid uncompressed block header: length verify\");if(a+g>d.length)throw Error(\"input buffer is broken\");switch(this.i){case A:for(;e+\r\ng>b.length;){m=k-e;g-=m;if(t)b.set(d.subarray(a,a+m),e),e+=m,a+=m;else for(;m--;)b[e++]=d[a++];this.b=e;b=this.e();e=this.b}break;case y:for(;e+g>b.length;)b=this.e({p:2});break;default:throw Error(\"invalid inflate mode\");}if(t)b.set(d.subarray(a,a+g),e),e+=g,a+=g;else for(;g--;)b[e++]=d[a++];this.a=a;this.b=e;this.c=b;break;case 1:this.j(ba,ca);break;case 2:for(var n=C(this,5)+257,p=C(this,5)+1,s=C(this,4)+4,x=new (t?Uint8Array:Array)(D.length),S=l,T=l,U=l,u=l,M=l,F=l,z=l,q=l,V=l,q=0;q<s;++q)x[D[q]]=\r\nC(this,3);if(!t){q=s;for(s=x.length;q<s;++q)x[D[q]]=0}S=v(x);u=new (t?Uint8Array:Array)(n+p);q=0;for(V=n+p;q<V;)switch(M=E(this,S),M){case 16:for(z=3+C(this,2);z--;)u[q++]=F;break;case 17:for(z=3+C(this,3);z--;)u[q++]=0;F=0;break;case 18:for(z=11+C(this,7);z--;)u[q++]=0;F=0;break;default:F=u[q++]=M}T=t?v(u.subarray(0,n)):v(u.slice(0,n));U=t?v(u.subarray(n)):v(u.slice(n));this.j(T,U);break;default:throw Error(\"unknown BTYPE: \"+c);}}return this.n()};\r\nvar G=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15],D=t?new Uint16Array(G):G,H=[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,258,258],I=t?new Uint16Array(H):H,J=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0],K=t?new Uint8Array(J):J,L=[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577],da=t?new Uint16Array(L):L,ea=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,\r\n13,13],N=t?new Uint8Array(ea):ea,O=new (t?Uint8Array:Array)(288),P,fa;P=0;for(fa=O.length;P<fa;++P)O[P]=143>=P?8:255>=P?9:279>=P?7:8;var ba=v(O),Q=new (t?Uint8Array:Array)(30),R,ga;R=0;for(ga=Q.length;R<ga;++R)Q[R]=5;var ca=v(Q);function C(c,d){for(var a=c.f,b=c.d,e=c.input,f=c.a,g=e.length,h;b<d;){if(f>=g)throw Error(\"input buffer is broken\");a|=e[f++]<<b;b+=8}h=a&(1<<d)-1;c.f=a>>>d;c.d=b-d;c.a=f;return h}\r\nfunction E(c,d){for(var a=c.f,b=c.d,e=c.input,f=c.a,g=e.length,h=d[0],k=d[1],m,n;b<k&&!(f>=g);)a|=e[f++]<<b,b+=8;m=h[a&(1<<k)-1];n=m>>>16;if(n>b)throw Error(\"invalid code length: \"+n);c.f=a>>n;c.d=b-n;c.a=f;return m&65535}\r\nw.prototype.j=function(c,d){var a=this.c,b=this.b;this.o=c;for(var e=a.length-258,f,g,h,k;256!==(f=E(this,c));)if(256>f)b>=e&&(this.b=b,a=this.e(),b=this.b),a[b++]=f;else{g=f-257;k=I[g];0<K[g]&&(k+=C(this,K[g]));f=E(this,d);h=da[f];0<N[f]&&(h+=C(this,N[f]));b>=e&&(this.b=b,a=this.e(),b=this.b);for(;k--;)a[b]=a[b++-h]}for(;8<=this.d;)this.d-=8,this.a--;this.b=b};\r\nw.prototype.w=function(c,d){var a=this.c,b=this.b;this.o=c;for(var e=a.length,f,g,h,k;256!==(f=E(this,c));)if(256>f)b>=e&&(a=this.e(),e=a.length),a[b++]=f;else{g=f-257;k=I[g];0<K[g]&&(k+=C(this,K[g]));f=E(this,d);h=da[f];0<N[f]&&(h+=C(this,N[f]));b+k>e&&(a=this.e(),e=a.length);for(;k--;)a[b]=a[b++-h]}for(;8<=this.d;)this.d-=8,this.a--;this.b=b};\r\nw.prototype.e=function(){var c=new (t?Uint8Array:Array)(this.b-32768),d=this.b-32768,a,b,e=this.c;if(t)c.set(e.subarray(32768,c.length));else{a=0;for(b=c.length;a<b;++a)c[a]=e[a+32768]}this.g.push(c);this.l+=c.length;if(t)e.set(e.subarray(d,d+32768));else for(a=0;32768>a;++a)e[a]=e[d+a];this.b=32768;return e};\r\nw.prototype.z=function(c){var d,a=this.input.length/this.a+1|0,b,e,f,g=this.input,h=this.c;c&&(\"number\"===typeof c.p&&(a=c.p),\"number\"===typeof c.u&&(a+=c.u));2>a?(b=(g.length-this.a)/this.o[2],f=258*(b/2)|0,e=f<h.length?h.length+f:h.length<<1):e=h.length*a;t?(d=new Uint8Array(e),d.set(h)):d=h;return this.c=d};\r\nw.prototype.n=function(){var c=0,d=this.c,a=this.g,b,e=new (t?Uint8Array:Array)(this.l+(this.b-32768)),f,g,h,k;if(0===a.length)return t?this.c.subarray(32768,this.b):this.c.slice(32768,this.b);f=0;for(g=a.length;f<g;++f){b=a[f];h=0;for(k=b.length;h<k;++h)e[c++]=b[h]}f=32768;for(g=this.b;f<g;++f)e[c++]=d[f];this.g=[];return this.buffer=e};\r\nw.prototype.v=function(){var c,d=this.b;t?this.r?(c=new Uint8Array(d),c.set(this.c.subarray(0,d))):c=this.c.subarray(0,d):(this.c.length>d&&(this.c.length=d),c=this.c);return this.buffer=c};function W(c,d){var a,b;this.input=c;this.a=0;if(d||!(d={}))d.index&&(this.a=d.index),d.verify&&(this.A=d.verify);a=c[this.a++];b=c[this.a++];switch(a&15){case ha:this.method=ha;break;default:throw Error(\"unsupported compression method\");}if(0!==((a<<8)+b)%31)throw Error(\"invalid fcheck flag:\"+((a<<8)+b)%31);if(b&32)throw Error(\"fdict flag is not supported\");this.q=new w(c,{index:this.a,bufferSize:d.bufferSize,bufferType:d.bufferType,resize:d.resize})}\r\nW.prototype.k=function(){var c=this.input,d,a;d=this.q.k();this.a=this.q.a;if(this.A){a=(c[this.a++]<<24|c[this.a++]<<16|c[this.a++]<<8|c[this.a++])>>>0;var b=d;if(\"string\"===typeof b){var e=b.split(\"\"),f,g;f=0;for(g=e.length;f<g;f++)e[f]=(e[f].charCodeAt(0)&255)>>>0;b=e}for(var h=1,k=0,m=b.length,n,p=0;0<m;){n=1024<m?1024:m;m-=n;do h+=b[p++],k+=h;while(--n);h%=65521;k%=65521}if(a!==(k<<16|h)>>>0)throw Error(\"invalid adler-32 checksum\");}return d};var ha=8;r(\"Zlib.Inflate\",W);r(\"Zlib.Inflate.prototype.decompress\",W.prototype.k);var X={ADAPTIVE:B.s,BLOCK:B.t},Y,Z,$,ia;if(Object.keys)Y=Object.keys(X);else for(Z in Y=[],$=0,X)Y[$++]=Z;$=0;for(ia=Y.length;$<ia;++$)Z=Y[$],r(\"Zlib.Inflate.BufferType.\"+Z,X[Z]);}).call(this);\r\n","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"Geometry\"},[_c('div',{attrs:{\"id\":\"Geometry\"}},[_c('div',{staticClass:\"operate\"},[_c('button',{staticClass:\"play\",on:{\"click\":_vm.display}},[_vm._v(\"play\")])])]),_c('div',{directives:[{name:\"show\",rawName:\"v-show\",value:(_vm.percentage !== 100),expression:\"percentage !== 100\"}],staticClass:\"mask\"},[_c('el-progress',{attrs:{\"text-inside\":true,\"stroke-width\":18,\"percentage\":_vm.percentage,\"status\":\"success\"}})],1)])}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nimport { Component, Vue } from 'vue-property-decorator'\nimport * as THREE from 'three'\nimport * as OrbitControls from 'three-orbitcontrols'\nimport FBXLoader from 'three-fbxloader-offical' // threejs-fbxloader\n\n@Component\n\nexport default class Geometry extends Vue {\n  private percentage: number = 0\n  private AnimationAction: any\n  public display () {\n    this.AnimationAction.play()\n  }\n  // public stop () {\n  //   this.AnimationAction.stop()\n  // }\n  public mounted () {\n    const scene = new THREE.Scene()\n    let mixer: any\n\n    const loader = new FBXLoader()\n    loader.load('/self/SambaDancing.fbx', (obj: any) => {\n      // console.log('fbxobj:',obj)\n      scene.add(obj)\n      obj.translateY(-80)\n      mixer = new THREE.AnimationMixer(obj)\n      this.AnimationAction = mixer.clipAction(obj.animations[0])\n      // this.AnimationAction.timeScale = 1; // 1\n      this.AnimationAction.loop = THREE.LoopOnce // \n      this.AnimationAction.clampWhenFinished = true // \n      // this.AnimationAction.play()\n    },// \n    (xhr: any) => {\n      this.percentage = xhr.loaded / xhr.total * 100\n    })\n    /**\n     * \n     */\n    // \n    const point = new THREE.PointLight(0xffffff)\n    point.position.set(400, 200, 300) // \n    scene.add(point) // \n    // \n    const ambient = new THREE.AmbientLight(0x444444)\n    scene.add(ambient)\n    /**\n     * \n     */\n    const width = window.innerWidth - 50 // \n    const height = window.innerHeight - 100 // \n    const k = width / height // \n    const s = 150 // \n    // \n    const camera = new THREE.OrthographicCamera(-s * k, s * k, s, -s, 1, 1000)\n    camera.position.set(200, 300, 200) // \n    camera.lookAt(scene.position) // ()\n    /**\n     * \n     */\n    const renderer = new THREE.WebGLRenderer()\n    renderer.setSize(width, height) // \n    renderer.setClearColor(0xb9d3ff, 1) // \n    const Geometry: HTMLElement | null = document.getElementById('Geometry')\n    if (Geometry) {\n      Geometry.appendChild(renderer.domElement)\n    }\n\n    // \n    function render () {\n      requestAnimationFrame(render) // render\n      rend()\n    }\n    render()\n    const clock = new THREE.Clock()\n    function rend () {\n      if (mixer) {\n        mixer.update(clock.getDelta())\n      }\n      camera.lookAt(scene.position)\n      renderer.render(scene, camera)\n    }\n    //   camera   \n    const controls = new OrbitControls(camera)\n  }\n}\n","import mod from \"-!../../node_modules/cache-loader/dist/cjs.js??ref--13-0!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js!../../node_modules/ts-loader/index.js??ref--13-3!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Animation.vue?vue&type=script&lang=ts&\"; export default mod; export * from \"-!../../node_modules/cache-loader/dist/cjs.js??ref--13-0!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js!../../node_modules/ts-loader/index.js??ref--13-3!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Animation.vue?vue&type=script&lang=ts&\"","import { render, staticRenderFns } from \"./Animation.vue?vue&type=template&id=34ae3e1f&\"\nimport script from \"./Animation.vue?vue&type=script&lang=ts&\"\nexport * from \"./Animation.vue?vue&type=script&lang=ts&\"\nimport style0 from \"./Animation.vue?vue&type=style&index=0&lang=less&\"\n\n\n/* normalize component */\nimport normalizer from \"!../../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\ncomponent.options.__file = \"Animation.vue\"\nexport default component.exports","import mod from \"-!../../node_modules/mini-css-extract-plugin/dist/loader.js??ref--10-oneOf-1-0!../../node_modules/css-loader/index.js??ref--10-oneOf-1-1!../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../node_modules/postcss-loader/src/index.js??ref--10-oneOf-1-2!../../node_modules/less-loader/dist/cjs.js??ref--10-oneOf-1-3!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Animation.vue?vue&type=style&index=0&lang=less&\"; export default mod; export * from \"-!../../node_modules/mini-css-extract-plugin/dist/loader.js??ref--10-oneOf-1-0!../../node_modules/css-loader/index.js??ref--10-oneOf-1-1!../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../node_modules/postcss-loader/src/index.js??ref--10-oneOf-1-2!../../node_modules/less-loader/dist/cjs.js??ref--10-oneOf-1-3!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Animation.vue?vue&type=style&index=0&lang=less&\"","const THREE = require('three');\nvar Zlib = require('./inflate.min').Zlib;\n\n/**\n * @author Kyle-Larson https://github.com/Kyle-Larson\n * @author Takahiro https://github.com/takahirox\n * @author Lewy Blue https://github.com/looeee\n *\n * Loader loads FBX file and generates Group representing FBX scene.\n * Requires FBX file to be >= 7.0 and in ASCII or >= 6400 in Binary format\n * Versions lower than this may load but will probably have errors\n *\n * Needs Support:\n *  Morph normals / blend shape normals\n *  Animation tracks for morph targets\n *\n *\tEuler rotation order\n *\n * FBX format references:\n * \thttps://wiki.blender.org/index.php/User:Mont29/Foundation/FBX_File_Structure\n * \thttp://help.autodesk.com/view/FBX/2017/ENU/?guid=__cpp_ref_index_html (C++ SDK reference)\n *\n * \tBinary format specification:\n *\t\thttps://code.blender.org/2013/08/fbx-binary-file-format-specification/\n */\n\n\nmodule.exports = ( function () {\n\n\tTHREE.FBXLoader = function ( manager ) {\n\n\t\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\n\n\t};\n\n\tObject.assign( THREE.FBXLoader.prototype, {\n\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\tvar self = this;\n\n\t\t\tvar resourceDirectory = THREE.LoaderUtils.extractUrlBase( url );\n\n\t\t\tvar loader = new THREE.FileLoader( this.manager );\n\t\t\tloader.setResponseType( 'arraybuffer' );\n\t\t\tloader.load( url, function ( buffer ) {\n\n\t\t\t\ttry {\n\n\t\t\t\t\tvar scene = self.parse( buffer, resourceDirectory );\n\t\t\t\t\tonLoad( scene );\n\n\t\t\t\t} catch ( error ) {\n\n\t\t\t\t\twindow.setTimeout( function () {\n\n\t\t\t\t\t\tif ( onError ) onError( error );\n\n\t\t\t\t\t\tself.manager.itemError( url );\n\n\t\t\t\t\t}, 0 );\n\n\t\t\t\t}\n\n\t\t\t}, onProgress, onError );\n\n\t\t},\n\n\t\tparse: function ( FBXBuffer, resourceDirectory ) {\n\n\t\t\tvar FBXTree;\n\n\t\t\tif ( isFbxFormatBinary( FBXBuffer ) ) {\n\n\t\t\t\tFBXTree = new BinaryParser().parse( FBXBuffer );\n\n\t\t\t} else {\n\n\t\t\t\tvar FBXText = convertArrayBufferToString( FBXBuffer );\n\n\t\t\t\tif ( ! isFbxFormatASCII( FBXText ) ) {\n\n\t\t\t\t\tthrow new Error( 'THREE.FBXLoader: Unknown format.' );\n\n\t\t\t\t}\n\n\t\t\t\tif ( getFbxVersion( FBXText ) < 7000 ) {\n\n\t\t\t\t\tthrow new Error( 'THREE.FBXLoader: FBX version not supported, FileVersion: ' + getFbxVersion( FBXText ) );\n\n\t\t\t\t}\n\n\t\t\t\tFBXTree = new TextParser().parse( FBXText );\n\n\t\t\t}\n\n\t\t\t// console.log( FBXTree );\n\n\t\t\tvar connections = parseConnections( FBXTree );\n\t\t\tvar images = parseImages( FBXTree );\n\t\t\tvar textures = parseTextures( FBXTree, new THREE.TextureLoader( this.manager ).setPath( resourceDirectory ), images, connections );\n\t\t\tvar materials = parseMaterials( FBXTree, textures, connections );\n\t\t\tvar deformers = parseDeformers( FBXTree, connections );\n\t\t\tvar geometryMap = parseGeometries( FBXTree, connections, deformers );\n\t\t\tvar sceneGraph = parseScene( FBXTree, connections, deformers.skeletons, geometryMap, materials );\n\n\t\t\treturn sceneGraph;\n\n\t\t}\n\n\t} );\n\n\t// Parses FBXTree.Connections which holds parent-child connections between objects (e.g. material -> texture, model->geometry )\n\t// and details the connection type\n\tfunction parseConnections( FBXTree ) {\n\n\t\tvar connectionMap = new Map();\n\n\t\tif ( 'Connections' in FBXTree ) {\n\n\t\t\tvar rawConnections = FBXTree.Connections.connections;\n\n\t\t\trawConnections.forEach( function ( rawConnection ) {\n\n\t\t\t\tvar fromID = rawConnection[ 0 ];\n\t\t\t\tvar toID = rawConnection[ 1 ];\n\t\t\t\tvar relationship = rawConnection[ 2 ];\n\n\t\t\t\tif ( ! connectionMap.has( fromID ) ) {\n\n\t\t\t\t\tconnectionMap.set( fromID, {\n\t\t\t\t\t\tparents: [],\n\t\t\t\t\t\tchildren: []\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t\tvar parentRelationship = { ID: toID, relationship: relationship };\n\t\t\t\tconnectionMap.get( fromID ).parents.push( parentRelationship );\n\n\t\t\t\tif ( ! connectionMap.has( toID ) ) {\n\n\t\t\t\t\tconnectionMap.set( toID, {\n\t\t\t\t\t\tparents: [],\n\t\t\t\t\t\tchildren: []\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t\tvar childRelationship = { ID: fromID, relationship: relationship };\n\t\t\t\tconnectionMap.get( toID ).children.push( childRelationship );\n\n\t\t\t} );\n\n\t\t}\n\n\t\treturn connectionMap;\n\n\t}\n\n\t// Parse FBXTree.Objects.Video for embedded image data\n\t// These images are connected to textures in FBXTree.Objects.Textures\n\t// via FBXTree.Connections.\n\tfunction parseImages( FBXTree ) {\n\n\t\tvar images = {};\n\t\tvar blobs = {};\n\n\t\tif ( 'Video' in FBXTree.Objects ) {\n\n\t\t\tvar videoNodes = FBXTree.Objects.Video;\n\n\t\t\tfor ( var nodeID in videoNodes ) {\n\n\t\t\t\tvar videoNode = videoNodes[ nodeID ];\n\n\t\t\t\tvar id = parseInt( nodeID );\n\n\t\t\t\timages[ id ] = videoNode.RelativeFilename || videoNode.Filename;\n\n\t\t\t\t// raw image data is in videoNode.Content\n\t\t\t\tif ( 'Content' in videoNode ) {\n\n\t\t\t\t\tvar arrayBufferContent = ( videoNode.Content instanceof ArrayBuffer ) && ( videoNode.Content.byteLength > 0 );\n\t\t\t\t\tvar base64Content = ( typeof videoNode.Content === 'string' ) && ( videoNode.Content !== '' );\n\n\t\t\t\t\tif ( arrayBufferContent || base64Content ) {\n\n\t\t\t\t\t\tvar image = parseImage( videoNodes[ nodeID ] );\n\n\t\t\t\t\t\tblobs[ videoNode.RelativeFilename || videoNode.Filename ] = image;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( var id in images ) {\n\n\t\t\tvar filename = images[ id ];\n\n\t\t\tif ( blobs[ filename ] !== undefined ) images[ id ] = blobs[ filename ];\n\t\t\telse images[ id ] = images[ id ].split( '\\\\' ).pop();\n\n\t\t}\n\n\t\treturn images;\n\n\t}\n\n\t// Parse embedded image data in FBXTree.Video.Content\n\tfunction parseImage( videoNode ) {\n\n\t\tvar content = videoNode.Content;\n\t\tvar fileName = videoNode.RelativeFilename || videoNode.Filename;\n\t\tvar extension = fileName.slice( fileName.lastIndexOf( '.' ) + 1 ).toLowerCase();\n\n\t\tvar type;\n\n\t\tswitch ( extension ) {\n\n\t\t\tcase 'bmp':\n\n\t\t\t\ttype = 'image/bmp';\n\t\t\t\tbreak;\n\n\t\t\tcase 'jpg':\n\t\t\tcase 'jpeg':\n\n\t\t\t\ttype = 'image/jpeg';\n\t\t\t\tbreak;\n\n\t\t\tcase 'png':\n\n\t\t\t\ttype = 'image/png';\n\t\t\t\tbreak;\n\n\t\t\tcase 'tif':\n\n\t\t\t\ttype = 'image/tiff';\n\t\t\t\tbreak;\n\n \t\t\tcase 'tga':\n\n\t\t\t\tif ( typeof THREE.TGALoader !== 'function' ) {\n\n\t\t\t\t\tconsole.warn( 'FBXLoader: THREE.TGALoader is required to load TGA textures' );\n\t\t\t\t\treturn;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( THREE.Loader.Handlers.get( '.tga' ) === null ) {\n\n\t\t\t\t\t\tTHREE.Loader.Handlers.add( /\\.tga$/i, new THREE.TGALoader() );\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttype = 'image/tga';\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\tdefault:\n\n\t\t\t\tconsole.warn( 'FBXLoader: Image type \"' + extension + '\" is not supported.' );\n\t\t\t\treturn;\n\n\t\t}\n\n\t\tif ( typeof content === 'string' ) { // ASCII format\n\n\t\t\treturn 'data:' + type + ';base64,' + content;\n\n\t\t} else { // Binary Format\n\n\t\t\tvar array = new Uint8Array( content );\n\t\t\treturn window.URL.createObjectURL( new Blob( [ array ], { type: type } ) );\n\n\t\t}\n\n\t}\n\n\t// Parse nodes in FBXTree.Objects.Texture\n\t// These contain details such as UV scaling, cropping, rotation etc and are connected\n\t// to images in FBXTree.Objects.Video\n\tfunction parseTextures( FBXTree, loader, images, connections ) {\n\n\t\tvar textureMap = new Map();\n\n\t\tif ( 'Texture' in FBXTree.Objects ) {\n\n\t\t\tvar textureNodes = FBXTree.Objects.Texture;\n\t\t\tfor ( var nodeID in textureNodes ) {\n\n\t\t\t\tvar texture = parseTexture( textureNodes[ nodeID ], loader, images, connections );\n\t\t\t\ttextureMap.set( parseInt( nodeID ), texture );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn textureMap;\n\n\t}\n\n\t// Parse individual node in FBXTree.Objects.Texture\n\tfunction parseTexture( textureNode, loader, images, connections ) {\n\n\t\tvar texture = loadTexture( textureNode, loader, images, connections );\n\n\t\ttexture.ID = textureNode.id;\n\n\t\ttexture.name = textureNode.attrName;\n\n\t\tvar wrapModeU = textureNode.WrapModeU;\n\t\tvar wrapModeV = textureNode.WrapModeV;\n\n\t\tvar valueU = wrapModeU !== undefined ? wrapModeU.value : 0;\n\t\tvar valueV = wrapModeV !== undefined ? wrapModeV.value : 0;\n\n\t\t// http://download.autodesk.com/us/fbx/SDKdocs/FBX_SDK_Help/files/fbxsdkref/class_k_fbx_texture.html#889640e63e2e681259ea81061b85143a\n\t\t// 0: repeat(default), 1: clamp\n\n\t\ttexture.wrapS = valueU === 0 ? THREE.RepeatWrapping : THREE.ClampToEdgeWrapping;\n\t\ttexture.wrapT = valueV === 0 ? THREE.RepeatWrapping : THREE.ClampToEdgeWrapping;\n\n\t\tif ( 'Scaling' in textureNode ) {\n\n\t\t\tvar values = textureNode.Scaling.value;\n\n\t\t\ttexture.repeat.x = values[ 0 ];\n\t\t\ttexture.repeat.y = values[ 1 ];\n\n\t\t}\n\n\t\treturn texture;\n\n\t}\n\n\t// load a texture specified as a blob or data URI, or via an external URL using THREE.TextureLoader\n\tfunction loadTexture( textureNode, loader, images, connections ) {\n\n\t\tvar fileName;\n\n\t\tvar currentPath = loader.path;\n\n\t\tvar children = connections.get( textureNode.id ).children;\n\n\t\tif ( children !== undefined && children.length > 0 && images[ children[ 0 ].ID ] !== undefined ) {\n\n\t\t\tfileName = images[ children[ 0 ].ID ];\n\n\t\t\tif ( fileName.indexOf( 'blob:' ) === 0 || fileName.indexOf( 'data:' ) === 0 ) {\n\n\t\t\t\tloader.setPath( undefined );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar texture;\n\n\t\tif ( textureNode.FileName.slice( -3 ).toLowerCase() === 'tga' ) {\n\n \t\t\ttexture = THREE.Loader.Handlers.get( '.tga' ).load( fileName );\n\n \t\t} else {\n\n \t\t\ttexture = loader.load( fileName );\n\n \t\t}\n\n\t\tloader.setPath( currentPath );\n\n\t\treturn texture;\n\n\t}\n\n\t// Parse nodes in FBXTree.Objects.Material\n\tfunction parseMaterials( FBXTree, textureMap, connections ) {\n\n\t\tvar materialMap = new Map();\n\n\t\tif ( 'Material' in FBXTree.Objects ) {\n\n\t\t\tvar materialNodes = FBXTree.Objects.Material;\n\n\t\t\tfor ( var nodeID in materialNodes ) {\n\n\t\t\t\tvar material = parseMaterial( FBXTree, materialNodes[ nodeID ], textureMap, connections );\n\n\t\t\t\tif ( material !== null ) materialMap.set( parseInt( nodeID ), material );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn materialMap;\n\n\t}\n\n\t// Parse single node in FBXTree.Objects.Material\n\t// Materials are connected to texture maps in FBXTree.Objects.Textures\n\t// FBX format currently only supports Lambert and Phong shading models\n\tfunction parseMaterial( FBXTree, materialNode, textureMap, connections ) {\n\n\t\tvar ID = materialNode.id;\n\t\tvar name = materialNode.attrName;\n\t\tvar type = materialNode.ShadingModel;\n\n\t\t//Case where FBX wraps shading model in property object.\n\t\tif ( typeof type === 'object' ) {\n\n\t\t\ttype = type.value;\n\n\t\t}\n\n\t\t// Ignore unused materials which don't have any connections.\n\t\tif ( ! connections.has( ID ) ) return null;\n\n\t\tvar parameters = parseParameters( FBXTree, materialNode, textureMap, ID, connections );\n\n\t\tvar material;\n\n\t\tswitch ( type.toLowerCase() ) {\n\n\t\t\tcase 'phong':\n\t\t\t\tmaterial = new THREE.MeshPhongMaterial();\n\t\t\t\tbreak;\n\t\t\tcase 'lambert':\n\t\t\t\tmaterial = new THREE.MeshLambertMaterial();\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tconsole.warn( 'THREE.FBXLoader: unknown material type \"%s\". Defaulting to MeshPhongMaterial.', type );\n\t\t\t\tmaterial = new THREE.MeshPhongMaterial( { color: 0x3300ff } );\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\tmaterial.setValues( parameters );\n\t\tmaterial.name = name;\n\n\t\treturn material;\n\n\t}\n\n\t// Parse FBX material and return parameters suitable for a three.js material\n\t// Also parse the texture map and return any textures associated with the material\n\tfunction parseParameters( FBXTree, properties, textureMap, ID, connections ) {\n\n\t\tvar parameters = {};\n\n\t\tif ( properties.BumpFactor ) {\n\n\t\t\tparameters.bumpScale = properties.BumpFactor.value;\n\n\t\t}\n\t\tif ( properties.Diffuse ) {\n\n\t\t\tparameters.color = new THREE.Color().fromArray( properties.Diffuse.value );\n\n\t\t} else if ( properties.DiffuseColor && properties.DiffuseColor.type === 'Color' ) {\n\n\t\t\t// The blender exporter exports diffuse here instead of in properties.Diffuse\n\t\t\tparameters.color = new THREE.Color().fromArray( properties.DiffuseColor.value );\n\n\t\t}\n\t\tif ( properties.DisplacementFactor ) {\n\n\t\t\tparameters.displacementScale = properties.DisplacementFactor.value;\n\n\t\t}\n\t\tif ( properties.Emissive ) {\n\n\t\t\tparameters.emissive = new THREE.Color().fromArray( properties.Emissive.value );\n\n\t\t} else if ( properties.EmissiveColor && properties.EmissiveColor.type === 'Color' ) {\n\n\t\t\t// The blender exporter exports emissive color here instead of in properties.Emissive\n\t\t\tparameters.emissive = new THREE.Color().fromArray( properties.EmissiveColor.value );\n\n\t\t}\n\t\tif ( properties.EmissiveFactor ) {\n\n\t\t\tparameters.emissiveIntensity = parseFloat( properties.EmissiveFactor.value );\n\n\t\t}\n\t\tif ( properties.Opacity ) {\n\n\t\t\tparameters.opacity = parseFloat( properties.Opacity.value );\n\n\t\t}\n\t\tif ( parameters.opacity < 1.0 ) {\n\n\t\t\tparameters.transparent = true;\n\n\t\t}\n\t\tif ( properties.ReflectionFactor ) {\n\n\t\t\tparameters.reflectivity = properties.ReflectionFactor.value;\n\n\t\t}\n\t\tif ( properties.Shininess ) {\n\n\t\t\tparameters.shininess = properties.Shininess.value;\n\n\t\t}\n\t\tif ( properties.Specular ) {\n\n\t\t\tparameters.specular = new THREE.Color().fromArray( properties.Specular.value );\n\n\t\t} else if ( properties.SpecularColor && properties.SpecularColor.type === 'Color' ) {\n\n\t\t\t// The blender exporter exports specular color here instead of in properties.Specular\n\t\t\tparameters.specular = new THREE.Color().fromArray( properties.SpecularColor.value );\n\n\t\t}\n\n\t\tconnections.get( ID ).children.forEach( function ( child ) {\n\n\t\t\tvar type = child.relationship;\n\n\t\t\tswitch ( type ) {\n\n\t\t\t\tcase 'Bump':\n\t\t\t\t\tparameters.bumpMap = textureMap.get( child.ID );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'DiffuseColor':\n\t\t\t\t\tparameters.map = getTexture( FBXTree, textureMap, child.ID, connections );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'DisplacementColor':\n\t\t\t\t\tparameters.displacementMap = getTexture( FBXTree, textureMap, child.ID, connections );\n\t\t\t\t\tbreak;\n\n\n\t\t\t\tcase 'EmissiveColor':\n\t\t\t\t\tparameters.emissiveMap = getTexture( FBXTree, textureMap, child.ID, connections );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'NormalMap':\n\t\t\t\t\tparameters.normalMap = getTexture( FBXTree, textureMap, child.ID, connections );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'ReflectionColor':\n\t\t\t\t\tparameters.envMap = getTexture( FBXTree, textureMap, child.ID, connections );\n\t\t\t\t\tparameters.envMap.mapping = THREE.EquirectangularReflectionMapping;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'SpecularColor':\n\t\t\t\t\tparameters.specularMap = getTexture( FBXTree, textureMap, child.ID, connections );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'TransparentColor':\n\t\t\t\t\tparameters.alphaMap = getTexture( FBXTree, textureMap, child.ID, connections );\n\t\t\t\t\tparameters.transparent = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'AmbientColor':\n\t\t\t\tcase 'ShininessExponent': // AKA glossiness map\n\t\t\t\tcase 'SpecularFactor': // AKA specularLevel\n\t\t\t\tcase 'VectorDisplacementColor': // NOTE: Seems to be a copy of DisplacementColor\n\t\t\t\tdefault:\n\t\t\t\t\tconsole.warn( 'THREE.FBXLoader: %s map is not supported in three.js, skipping texture.', type );\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t} );\n\n\t\treturn parameters;\n\n\t}\n\n\t// get a texture from the textureMap for use by a material.\n\tfunction getTexture( FBXTree, textureMap, id, connections ) {\n\n\t\t// if the texture is a layered texture, just use the first layer and issue a warning\n\t\tif ( 'LayeredTexture' in FBXTree.Objects && id in FBXTree.Objects.LayeredTexture ) {\n\n\t\t\tconsole.warn( 'THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer.' );\n\t\t\tid = connections.get( id ).children[ 0 ].ID;\n\n\t\t}\n\n\t\treturn textureMap.get( id );\n\n\t}\n\n\t// Parse nodes in FBXTree.Objects.Deformer\n\t// Deformer node can contain skinning or Vertex Cache animation data, however only skinning is supported here\n\t// Generates map of Skeleton-like objects for use later when generating and binding skeletons.\n\tfunction parseDeformers( FBXTree, connections ) {\n\n\t\tvar skeletons = {};\n\t\tvar morphTargets = {};\n\n\t\tif ( 'Deformer' in FBXTree.Objects ) {\n\n\t\t\tvar DeformerNodes = FBXTree.Objects.Deformer;\n\n\t\t\tfor ( var nodeID in DeformerNodes ) {\n\n\t\t\t\tvar deformerNode = DeformerNodes[ nodeID ];\n\n\t\t\t\tvar relationships = connections.get( parseInt( nodeID ) );\n\n\t\t\t\tif ( deformerNode.attrType === 'Skin' ) {\n\n\t\t\t\t\tvar skeleton = parseSkeleton( relationships, DeformerNodes );\n\t\t\t\t\tskeleton.ID = nodeID;\n\n\t\t\t\t\tif ( relationships.parents.length > 1 ) console.warn( 'THREE.FBXLoader: skeleton attached to more than one geometry is not supported.' );\n\t\t\t\t\tskeleton.geometryID = relationships.parents[ 0 ].ID;\n\n\t\t\t\t\tskeletons[ nodeID ] = skeleton;\n\n\t\t\t\t} else if ( deformerNode.attrType === 'BlendShape' ) {\n\n\t\t\t\t\tvar morphTarget = {\n\t\t\t\t\t\tid: nodeID,\n\t\t\t\t\t};\n\n\t\t\t\t\tmorphTarget.rawTargets = parseMorphTargets( relationships, deformerNode, DeformerNodes, connections, FBXTree );\n\t\t\t\t\tmorphTarget.id = nodeID;\n\n\t\t\t\t\tif ( relationships.parents.length > 1 ) console.warn( 'THREE.FBXLoader: morph target attached to more than one geometry is not supported.' );\n\t\t\t\t\tmorphTarget.parentGeoID = relationships.parents[ 0 ].ID;\n\n\t\t\t\t\tmorphTargets[ nodeID ] = morphTarget;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn {\n\n\t\t\tskeletons: skeletons,\n\t\t\tmorphTargets: morphTargets,\n\n\t\t};\n\n\t}\n\n\t// Parse single nodes in FBXTree.Objects.Deformer\n\t// The top level skeleton node has type 'Skin' and sub nodes have type 'Cluster'\n\t// Each skin node represents a skeleton and each cluster node represents a bone\n\tfunction parseSkeleton( connections, deformerNodes ) {\n\n\t\tvar rawBones = [];\n\n\t\tconnections.children.forEach( function ( child ) {\n\n\t\t\tvar boneNode = deformerNodes[ child.ID ];\n\n\t\t\tif ( boneNode.attrType !== 'Cluster' ) return;\n\n\t\t\tvar rawBone = {\n\n\t\t\t\tID: child.ID,\n\t\t\t\tindices: [],\n\t\t\t\tweights: [],\n\t\t\t\ttransform: new THREE.Matrix4().fromArray( boneNode.Transform.a ),\n\t\t\t\ttransformLink: new THREE.Matrix4().fromArray( boneNode.TransformLink.a ),\n\t\t\t\tlinkMode: boneNode.Mode,\n\n\t\t\t};\n\n\t\t\tif ( 'Indexes' in boneNode ) {\n\n\t\t\t\trawBone.indices = boneNode.Indexes.a;\n\t\t\t\trawBone.weights = boneNode.Weights.a;\n\n\t\t\t}\n\n\t\t\trawBones.push( rawBone );\n\n\t\t} );\n\n\t\treturn {\n\n\t\t\trawBones: rawBones,\n\t\t\tbones: []\n\n\t\t};\n\n\t}\n\n\t// The top level morph deformer node has type \"BlendShape\" and sub nodes have type \"BlendShapeChannel\"\n\tfunction parseMorphTargets( relationships, deformerNode, deformerNodes, connections ) {\n\n\t\tvar rawMorphTargets = [];\n\n\t\tfor ( var i = 0; i < relationships.children.length; i ++ ) {\n\n\t\t\tif ( i === 8 ) {\n\n\t\t\t\tconsole.warn( 'FBXLoader: maximum of 8 morph targets supported. Ignoring additional targets.' );\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tvar child = relationships.children[ i ];\n\n\t\t\tvar morphTargetNode = deformerNodes[ child.ID ];\n\n\t\t\tvar rawMorphTarget = {\n\n\t\t\t\tname: morphTargetNode.attrName,\n\t\t\t\tinitialWeight: morphTargetNode.DeformPercent,\n\t\t\t\tid: morphTargetNode.id,\n\t\t\t\tfullWeights: morphTargetNode.FullWeights.a\n\n\t\t\t};\n\n\t\t\tif ( morphTargetNode.attrType !== 'BlendShapeChannel' ) return;\n\n\t\t\tvar targetRelationships = connections.get( parseInt( child.ID ) );\n\n\t\t\ttargetRelationships.children.forEach( function ( child ) {\n\n\t\t\t\tif ( child.relationship === 'DeformPercent' ) {\n\n\t\t\t\t\t// TODO: animation of morph targets is currently unsupported\n\t\t\t\t\trawMorphTarget.weightCurveID = child.ID;\n\t\t\t\t\t// weightCurve = FBXTree.Objects.AnimationCurveNode[ weightCurveID ];\n\n\t\t\t\t} else {\n\n\t\t\t\t\trawMorphTarget.geoID = child.ID;\n\t\t\t\t\t// morphGeo = FBXTree.Objects.Geometry[ geoID ];\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\trawMorphTargets.push( rawMorphTarget );\n\n\t\t}\n\n\t\treturn rawMorphTargets;\n\n\t}\n\n\t// Parse nodes in FBXTree.Objects.Geometry\n\tfunction parseGeometries( FBXTree, connections, deformers ) {\n\n\t\tvar geometryMap = new Map();\n\n\t\tif ( 'Geometry' in FBXTree.Objects ) {\n\n\t\t\tvar geoNodes = FBXTree.Objects.Geometry;\n\n\t\t\tfor ( var nodeID in geoNodes ) {\n\n\t\t\t\tvar relationships = connections.get( parseInt( nodeID ) );\n\t\t\t\tvar geo = parseGeometry( FBXTree, relationships, geoNodes[ nodeID ], deformers );\n\n\t\t\t\tgeometryMap.set( parseInt( nodeID ), geo );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn geometryMap;\n\n\t}\n\n\t// Parse single node in FBXTree.Objects.Geometry\n\tfunction parseGeometry( FBXTree, relationships, geoNode, deformers ) {\n\n\t\tswitch ( geoNode.attrType ) {\n\n\t\t\tcase 'Mesh':\n\t\t\t\treturn parseMeshGeometry( FBXTree, relationships, geoNode, deformers );\n\t\t\t\tbreak;\n\n\t\t\tcase 'NurbsCurve':\n\t\t\t\treturn parseNurbsGeometry( geoNode );\n\t\t\t\tbreak;\n\n\t\t}\n\n\t}\n\n\t// Parse single node mesh geometry in FBXTree.Objects.Geometry\n\tfunction parseMeshGeometry( FBXTree, relationships, geoNode, deformers ) {\n\n\t\tvar skeletons = deformers.skeletons;\n\t\tvar morphTargets = deformers.morphTargets;\n\n\t\tvar modelNodes = relationships.parents.map( function ( parent ) {\n\n\t\t\treturn FBXTree.Objects.Model[ parent.ID ];\n\n\t\t} );\n\n\t\t// don't create geometry if it is not associated with any models\n\t\tif ( modelNodes.length === 0 ) return;\n\n\t\tvar skeleton = relationships.children.reduce( function ( skeleton, child ) {\n\n\t\t\tif ( skeletons[ child.ID ] !== undefined ) skeleton = skeletons[ child.ID ];\n\n\t\t\treturn skeleton;\n\n\t\t}, null );\n\n\t\tvar morphTarget = relationships.children.reduce( function ( morphTarget, child ) {\n\n\t\t\tif ( morphTargets[ child.ID ] !== undefined ) morphTarget = morphTargets[ child.ID ];\n\n\t\t\treturn morphTarget;\n\n\t\t}, null );\n\n\t\tvar preTransform = new THREE.Matrix4();\n\n\t\t// TODO: if there is more than one model associated with the geometry, AND the models have\n\t\t// different geometric transforms, then this will cause problems\n\t\t// if ( modelNodes.length > 1 ) { }\n\n\t\t// For now just assume one model and get the preRotations from that\n\t\tvar modelNode = modelNodes[ 0 ];\n\n\t\tif ( 'GeometricRotation' in modelNode ) {\n\n\t\t\tvar array = modelNode.GeometricRotation.value.map( THREE.Math.degToRad );\n\t\t\tarray[ 3 ] = 'ZYX';\n\n\t\t\tpreTransform.makeRotationFromEuler( new THREE.Euler().fromArray( array ) );\n\n\t\t}\n\n\t\tif ( 'GeometricTranslation' in modelNode ) {\n\n\t\t\tpreTransform.setPosition( new THREE.Vector3().fromArray( modelNode.GeometricTranslation.value ) );\n\n\t\t}\n\n\t\tif ( 'GeometricScaling' in modelNode ) {\n\n\t\t\tpreTransform.scale( new THREE.Vector3().fromArray( modelNode.GeometricScaling.value ) );\n\n\t\t}\n\n\t\treturn genGeometry( FBXTree, geoNode, skeleton, morphTarget, preTransform );\n\n\t}\n\n\t// Generate a THREE.BufferGeometry from a node in FBXTree.Objects.Geometry\n\tfunction genGeometry( FBXTree, geoNode, skeleton, morphTarget, preTransform ) {\n\n\t\tvar geo = new THREE.BufferGeometry();\n\t\tif ( geoNode.attrName ) geo.name = geoNode.attrName;\n\n\t\tvar geoInfo = getGeoInfo( geoNode, skeleton );\n\n\t\tvar buffers = genBuffers( geoInfo );\n\n\t\tvar positionAttribute = new THREE.Float32BufferAttribute( buffers.vertex, 3 );\n\n\t\tpreTransform.applyToBufferAttribute( positionAttribute );\n\n\t\tgeo.addAttribute( 'position', positionAttribute );\n\n\t\tif ( buffers.colors.length > 0 ) {\n\n\t\t\tgeo.addAttribute( 'color', new THREE.Float32BufferAttribute( buffers.colors, 3 ) );\n\n\t\t}\n\n\t\tif ( skeleton ) {\n\n\t\t\tgeo.addAttribute( 'skinIndex', new THREE.Uint16BufferAttribute( buffers.weightsIndices, 4 ) );\n\n\t\t\tgeo.addAttribute( 'skinWeight', new THREE.Float32BufferAttribute( buffers.vertexWeights, 4 ) );\n\n\t\t\t// used later to bind the skeleton to the model\n\t\t\tgeo.FBX_Deformer = skeleton;\n\n\t\t}\n\n\t\tif ( buffers.normal.length > 0 ) {\n\n\t\t\tvar normalAttribute = new THREE.Float32BufferAttribute( buffers.normal, 3 );\n\n\t\t\tvar normalMatrix = new THREE.Matrix3().getNormalMatrix( preTransform );\n\t\t\tnormalMatrix.applyToBufferAttribute( normalAttribute );\n\n\t\t\tgeo.addAttribute( 'normal', normalAttribute );\n\n\t\t}\n\n\t\tbuffers.uvs.forEach( function ( uvBuffer, i ) {\n\n\t\t\t// subsequent uv buffers are called 'uv1', 'uv2', ...\n\t\t\tvar name = 'uv' + ( i + 1 ).toString();\n\n\t\t\t// the first uv buffer is just called 'uv'\n\t\t\tif ( i === 0 ) {\n\n\t\t\t\tname = 'uv';\n\n\t\t\t}\n\n\t\t\tgeo.addAttribute( name, new THREE.Float32BufferAttribute( buffers.uvs[ i ], 2 ) );\n\n\t\t} );\n\n\t\tif ( geoInfo.material && geoInfo.material.mappingType !== 'AllSame' ) {\n\n\t\t\t// Convert the material indices of each vertex into rendering groups on the geometry.\n\t\t\tvar prevMaterialIndex = buffers.materialIndex[ 0 ];\n\t\t\tvar startIndex = 0;\n\n\t\t\tbuffers.materialIndex.forEach( function ( currentIndex, i ) {\n\n\t\t\t\tif ( currentIndex !== prevMaterialIndex ) {\n\n\t\t\t\t\tgeo.addGroup( startIndex, i - startIndex, prevMaterialIndex );\n\n\t\t\t\t\tprevMaterialIndex = currentIndex;\n\t\t\t\t\tstartIndex = i;\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\t// the loop above doesn't add the last group, do that here.\n\t\t\tif ( geo.groups.length > 0 ) {\n\n\t\t\t\tvar lastGroup = geo.groups[ geo.groups.length - 1 ];\n\t\t\t\tvar lastIndex = lastGroup.start + lastGroup.count;\n\n\t\t\t\tif ( lastIndex !== buffers.materialIndex.length ) {\n\n\t\t\t\t\tgeo.addGroup( lastIndex, buffers.materialIndex.length - lastIndex, prevMaterialIndex );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// case where there are multiple materials but the whole geometry is only\n\t\t\t// using one of them\n\t\t\tif ( geo.groups.length === 0 ) {\n\n\t\t\t\tgeo.addGroup( 0, buffers.materialIndex.length, buffers.materialIndex[ 0 ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\taddMorphTargets( FBXTree, geo, geoNode, morphTarget, preTransform );\n\n\t\treturn geo;\n\n\t}\n\n\tfunction getGeoInfo( geoNode, skeleton ) {\n\n\t\tvar geoInfo = {};\n\n\t\tgeoInfo.vertexPositions = ( geoNode.Vertices !== undefined ) ? geoNode.Vertices.a : [];\n\t\tgeoInfo.vertexIndices = ( geoNode.PolygonVertexIndex !== undefined ) ? geoNode.PolygonVertexIndex.a : [];\n\n\t\tif ( geoNode.LayerElementColor ) {\n\n\t\t\tgeoInfo.color = getColors( geoNode.LayerElementColor[ 0 ] );\n\n\t\t}\n\n\t\tif ( geoNode.LayerElementMaterial ) {\n\n\t\t\tgeoInfo.material = getMaterials( geoNode.LayerElementMaterial[ 0 ] );\n\n\t\t}\n\n\t\tif ( geoNode.LayerElementNormal ) {\n\n\t\t\tgeoInfo.normal = getNormals( geoNode.LayerElementNormal[ 0 ] );\n\n\t\t}\n\n\t\tif ( geoNode.LayerElementUV ) {\n\n\t\t\tgeoInfo.uv = [];\n\n\t\t\tvar i = 0;\n\t\t\twhile ( geoNode.LayerElementUV[ i ] ) {\n\n\t\t\t\tgeoInfo.uv.push( getUVs( geoNode.LayerElementUV[ i ] ) );\n\t\t\t\ti ++;\n\n\t\t\t}\n\n\t\t}\n\n\t\tgeoInfo.weightTable = {};\n\n\t\tif ( skeleton !== null ) {\n\n\t\t\tgeoInfo.skeleton = skeleton;\n\n\t\t\tskeleton.rawBones.forEach( function ( rawBone, i ) {\n\n\t\t\t\t// loop over the bone's vertex indices and weights\n\t\t\t\trawBone.indices.forEach( function ( index, j ) {\n\n\t\t\t\t\tif ( geoInfo.weightTable[ index ] === undefined ) geoInfo.weightTable[ index ] = [];\n\n\t\t\t\t\tgeoInfo.weightTable[ index ].push( {\n\n\t\t\t\t\t\tid: i,\n\t\t\t\t\t\tweight: rawBone.weights[ j ],\n\n\t\t\t\t\t} );\n\n\t\t\t\t} );\n\n\t\t\t} );\n\n\t\t}\n\n\t\treturn geoInfo;\n\n\t}\n\n\tfunction genBuffers( geoInfo ) {\n\n\t\tvar buffers = {\n\t\t\tvertex: [],\n\t\t\tnormal: [],\n\t\t\tcolors: [],\n\t\t\tuvs: [],\n\t\t\tmaterialIndex: [],\n\t\t\tvertexWeights: [],\n\t\t\tweightsIndices: [],\n\t\t};\n\n\t\tvar polygonIndex = 0;\n\t\tvar faceLength = 0;\n\t\tvar displayedWeightsWarning = false;\n\n\t\t// these will hold data for a single face\n\t\tvar facePositionIndexes = [];\n\t\tvar faceNormals = [];\n\t\tvar faceColors = [];\n\t\tvar faceUVs = [];\n\t\tvar faceWeights = [];\n\t\tvar faceWeightIndices = [];\n\n\t\tgeoInfo.vertexIndices.forEach( function ( vertexIndex, polygonVertexIndex ) {\n\n\t\t\tvar endOfFace = false;\n\n\t\t\t// Face index and vertex index arrays are combined in a single array\n\t\t\t// A cube with quad faces looks like this:\n\t\t\t// PolygonVertexIndex: *24 {\n\t\t\t//  a: 0, 1, 3, -3, 2, 3, 5, -5, 4, 5, 7, -7, 6, 7, 1, -1, 1, 7, 5, -4, 6, 0, 2, -5\n\t\t\t//  }\n\t\t\t// Negative numbers mark the end of a face - first face here is 0, 1, 3, -3\n\t\t\t// to find index of last vertex bit shift the index: ^ - 1\n\t\t\tif ( vertexIndex < 0 ) {\n\n\t\t\t\tvertexIndex = vertexIndex ^ - 1; // equivalent to ( x * -1 ) - 1\n\t\t\t\tendOfFace = true;\n\n\t\t\t}\n\n\t\t\tvar weightIndices = [];\n\t\t\tvar weights = [];\n\n\t\t\tfacePositionIndexes.push( vertexIndex * 3, vertexIndex * 3 + 1, vertexIndex * 3 + 2 );\n\n\t\t\tif ( geoInfo.color ) {\n\n\t\t\t\tvar data = getData( polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.color );\n\n\t\t\t\tfaceColors.push( data[ 0 ], data[ 1 ], data[ 2 ] );\n\n\t\t\t}\n\n\t\t\tif ( geoInfo.skeleton ) {\n\n\t\t\t\tif ( geoInfo.weightTable[ vertexIndex ] !== undefined ) {\n\n\t\t\t\t\tgeoInfo.weightTable[ vertexIndex ].forEach( function ( wt ) {\n\n\t\t\t\t\t\tweights.push( wt.weight );\n\t\t\t\t\t\tweightIndices.push( wt.id );\n\n\t\t\t\t\t} );\n\n\n\t\t\t\t}\n\n\t\t\t\tif ( weights.length > 4 ) {\n\n\t\t\t\t\tif ( ! displayedWeightsWarning ) {\n\n\t\t\t\t\t\tconsole.warn( 'THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights.' );\n\t\t\t\t\t\tdisplayedWeightsWarning = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar wIndex = [ 0, 0, 0, 0 ];\n\t\t\t\t\tvar Weight = [ 0, 0, 0, 0 ];\n\n\t\t\t\t\tweights.forEach( function ( weight, weightIndex ) {\n\n\t\t\t\t\t\tvar currentWeight = weight;\n\t\t\t\t\t\tvar currentIndex = weightIndices[ weightIndex ];\n\n\t\t\t\t\t\tWeight.forEach( function ( comparedWeight, comparedWeightIndex, comparedWeightArray ) {\n\n\t\t\t\t\t\t\tif ( currentWeight > comparedWeight ) {\n\n\t\t\t\t\t\t\t\tcomparedWeightArray[ comparedWeightIndex ] = currentWeight;\n\t\t\t\t\t\t\t\tcurrentWeight = comparedWeight;\n\n\t\t\t\t\t\t\t\tvar tmp = wIndex[ comparedWeightIndex ];\n\t\t\t\t\t\t\t\twIndex[ comparedWeightIndex ] = currentIndex;\n\t\t\t\t\t\t\t\tcurrentIndex = tmp;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t} );\n\n\t\t\t\t\tweightIndices = wIndex;\n\t\t\t\t\tweights = Weight;\n\n\t\t\t\t}\n\n\t\t\t\t// if the weight array is shorter than 4 pad with 0s\n\t\t\t\twhile ( weights.length < 4 ) {\n\n\t\t\t\t\tweights.push( 0 );\n\t\t\t\t\tweightIndices.push( 0 );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( var i = 0; i < 4; ++ i ) {\n\n\t\t\t\t\tfaceWeights.push( weights[ i ] );\n\t\t\t\t\tfaceWeightIndices.push( weightIndices[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( geoInfo.normal ) {\n\n\t\t\t\tvar data = getData( polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.normal );\n\n\t\t\t\tfaceNormals.push( data[ 0 ], data[ 1 ], data[ 2 ] );\n\n\t\t\t}\n\n\t\t\tif ( geoInfo.material && geoInfo.material.mappingType !== 'AllSame' ) {\n\n\t\t\t\tvar materialIndex = getData( polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.material )[ 0 ];\n\n\t\t\t}\n\n\t\t\tif ( geoInfo.uv ) {\n\n\t\t\t\tgeoInfo.uv.forEach( function ( uv, i ) {\n\n\t\t\t\t\tvar data = getData( polygonVertexIndex, polygonIndex, vertexIndex, uv );\n\n\t\t\t\t\tif ( faceUVs[ i ] === undefined ) {\n\n\t\t\t\t\t\tfaceUVs[ i ] = [];\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfaceUVs[ i ].push( data[ 0 ] );\n\t\t\t\t\tfaceUVs[ i ].push( data[ 1 ] );\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tfaceLength ++;\n\n\t\t\tif ( endOfFace ) {\n\n\t\t\t\tgenFace( buffers, geoInfo, facePositionIndexes, materialIndex, faceNormals, faceColors, faceUVs, faceWeights, faceWeightIndices, faceLength );\n\n\t\t\t\tpolygonIndex ++;\n\t\t\t\tfaceLength = 0;\n\n\t\t\t\t// reset arrays for the next face\n\t\t\t\tfacePositionIndexes = [];\n\t\t\t\tfaceNormals = [];\n\t\t\t\tfaceColors = [];\n\t\t\t\tfaceUVs = [];\n\t\t\t\tfaceWeights = [];\n\t\t\t\tfaceWeightIndices = [];\n\n\t\t\t}\n\n\t\t} );\n\n\t\treturn buffers;\n\n\t}\n\n\t// Generate data for a single face in a geometry. If the face is a quad then split it into 2 tris\n\tfunction genFace( buffers, geoInfo, facePositionIndexes, materialIndex, faceNormals, faceColors, faceUVs, faceWeights, faceWeightIndices, faceLength ) {\n\n\t\tfor ( var i = 2; i < faceLength; i ++ ) {\n\n\t\t\tbuffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ 0 ] ] );\n\t\t\tbuffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ 1 ] ] );\n\t\t\tbuffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ 2 ] ] );\n\n\t\t\tbuffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ ( i - 1 ) * 3 ] ] );\n\t\t\tbuffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ ( i - 1 ) * 3 + 1 ] ] );\n\t\t\tbuffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ ( i - 1 ) * 3 + 2 ] ] );\n\n\t\t\tbuffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ i * 3 ] ] );\n\t\t\tbuffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ i * 3 + 1 ] ] );\n\t\t\tbuffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ i * 3 + 2 ] ] );\n\n\t\t\tif ( geoInfo.skeleton ) {\n\n\t\t\t\tbuffers.vertexWeights.push( faceWeights[ 0 ] );\n\t\t\t\tbuffers.vertexWeights.push( faceWeights[ 1 ] );\n\t\t\t\tbuffers.vertexWeights.push( faceWeights[ 2 ] );\n\t\t\t\tbuffers.vertexWeights.push( faceWeights[ 3 ] );\n\n\t\t\t\tbuffers.vertexWeights.push( faceWeights[ ( i - 1 ) * 4 ] );\n\t\t\t\tbuffers.vertexWeights.push( faceWeights[ ( i - 1 ) * 4 + 1 ] );\n\t\t\t\tbuffers.vertexWeights.push( faceWeights[ ( i - 1 ) * 4 + 2 ] );\n\t\t\t\tbuffers.vertexWeights.push( faceWeights[ ( i - 1 ) * 4 + 3 ] );\n\n\t\t\t\tbuffers.vertexWeights.push( faceWeights[ i * 4 ] );\n\t\t\t\tbuffers.vertexWeights.push( faceWeights[ i * 4 + 1 ] );\n\t\t\t\tbuffers.vertexWeights.push( faceWeights[ i * 4 + 2 ] );\n\t\t\t\tbuffers.vertexWeights.push( faceWeights[ i * 4 + 3 ] );\n\n\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ 0 ] );\n\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ 1 ] );\n\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ 2 ] );\n\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ 3 ] );\n\n\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ ( i - 1 ) * 4 ] );\n\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ ( i - 1 ) * 4 + 1 ] );\n\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ ( i - 1 ) * 4 + 2 ] );\n\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ ( i - 1 ) * 4 + 3 ] );\n\n\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ i * 4 ] );\n\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ i * 4 + 1 ] );\n\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ i * 4 + 2 ] );\n\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ i * 4 + 3 ] );\n\n\t\t\t}\n\n\t\t\tif ( geoInfo.color ) {\n\n\t\t\t\tbuffers.colors.push( faceColors[ 0 ] );\n\t\t\t\tbuffers.colors.push( faceColors[ 1 ] );\n\t\t\t\tbuffers.colors.push( faceColors[ 2 ] );\n\n\t\t\t\tbuffers.colors.push( faceColors[ ( i - 1 ) * 3 ] );\n\t\t\t\tbuffers.colors.push( faceColors[ ( i - 1 ) * 3 + 1 ] );\n\t\t\t\tbuffers.colors.push( faceColors[ ( i - 1 ) * 3 + 2 ] );\n\n\t\t\t\tbuffers.colors.push( faceColors[ i * 3 ] );\n\t\t\t\tbuffers.colors.push( faceColors[ i * 3 + 1 ] );\n\t\t\t\tbuffers.colors.push( faceColors[ i * 3 + 2 ] );\n\n\t\t\t}\n\n\t\t\tif ( geoInfo.material && geoInfo.material.mappingType !== 'AllSame' ) {\n\n\t\t\t\tbuffers.materialIndex.push( materialIndex );\n\t\t\t\tbuffers.materialIndex.push( materialIndex );\n\t\t\t\tbuffers.materialIndex.push( materialIndex );\n\n\t\t\t}\n\n\t\t\tif ( geoInfo.normal ) {\n\n\t\t\t\tbuffers.normal.push( faceNormals[ 0 ] );\n\t\t\t\tbuffers.normal.push( faceNormals[ 1 ] );\n\t\t\t\tbuffers.normal.push( faceNormals[ 2 ] );\n\n\t\t\t\tbuffers.normal.push( faceNormals[ ( i - 1 ) * 3 ] );\n\t\t\t\tbuffers.normal.push( faceNormals[ ( i - 1 ) * 3 + 1 ] );\n\t\t\t\tbuffers.normal.push( faceNormals[ ( i - 1 ) * 3 + 2 ] );\n\n\t\t\t\tbuffers.normal.push( faceNormals[ i * 3 ] );\n\t\t\t\tbuffers.normal.push( faceNormals[ i * 3 + 1 ] );\n\t\t\t\tbuffers.normal.push( faceNormals[ i * 3 + 2 ] );\n\n\t\t\t}\n\n\t\t\tif ( geoInfo.uv ) {\n\n\t\t\t\tgeoInfo.uv.forEach( function ( uv, j ) {\n\n\t\t\t\t\tif ( buffers.uvs[ j ] === undefined ) buffers.uvs[ j ] = [];\n\n\t\t\t\t\tbuffers.uvs[ j ].push( faceUVs[ j ][ 0 ] );\n\t\t\t\t\tbuffers.uvs[ j ].push( faceUVs[ j ][ 1 ] );\n\n\t\t\t\t\tbuffers.uvs[ j ].push( faceUVs[ j ][ ( i - 1 ) * 2 ] );\n\t\t\t\t\tbuffers.uvs[ j ].push( faceUVs[ j ][ ( i - 1 ) * 2 + 1 ] );\n\n\t\t\t\t\tbuffers.uvs[ j ].push( faceUVs[ j ][ i * 2 ] );\n\t\t\t\t\tbuffers.uvs[ j ].push( faceUVs[ j ][ i * 2 + 1 ] );\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tfunction addMorphTargets( FBXTree, parentGeo, parentGeoNode, morphTarget, preTransform ) {\n\n\t\tif ( morphTarget === null ) return;\n\n\t\tparentGeo.morphAttributes.position = [];\n\t\tparentGeo.morphAttributes.normal = [];\n\n\t\tmorphTarget.rawTargets.forEach( function ( rawTarget ) {\n\n\t\t\tvar morphGeoNode = FBXTree.Objects.Geometry[ rawTarget.geoID ];\n\n\t\t\tif ( morphGeoNode !== undefined ) {\n\n\t\t\t\tgenMorphGeometry( parentGeo, parentGeoNode, morphGeoNode, preTransform );\n\n\t\t\t}\n\n\t\t} );\n\n\t}\n\n\t// a morph geometry node is similar to a standard  node, and the node is also contained\n\t// in FBXTree.Objects.Geometry, however it can only have attributes for position, normal\n\t// and a special attribute Index defining which vertices of the original geometry are affected\n\t// Normal and position attributes only have data for the vertices that are affected by the morph\n\tfunction genMorphGeometry( parentGeo, parentGeoNode, morphGeoNode, preTransform ) {\n\n\t\tvar morphGeo = new THREE.BufferGeometry();\n\t\tif ( morphGeoNode.attrName ) morphGeo.name = morphGeoNode.attrName;\n\n\t\tvar vertexIndices = ( parentGeoNode.PolygonVertexIndex !== undefined ) ? parentGeoNode.PolygonVertexIndex.a : [];\n\n\t\t// make a copy of the parent's vertex positions\n\t\tvar vertexPositions = ( parentGeoNode.Vertices !== undefined ) ? parentGeoNode.Vertices.a.slice() : [];\n\n\t\tvar morphPositions = ( morphGeoNode.Vertices !== undefined ) ? morphGeoNode.Vertices.a : [];\n\t\tvar indices = ( morphGeoNode.Indexes !== undefined ) ? morphGeoNode.Indexes.a : [];\n\n\t\tfor ( var i = 0; i < indices.length; i ++ ) {\n\n\t\t\tvar morphIndex = indices[ i ] * 3;\n\n\t\t\t// FBX format uses blend shapes rather than morph targets. This can be converted\n\t\t\t// by additively combining the blend shape positions with the original geometry's positions\n\t\t\tvertexPositions[ morphIndex ] += morphPositions[ i * 3 ];\n\t\t\tvertexPositions[ morphIndex + 1 ] += morphPositions[ i * 3 + 1 ];\n\t\t\tvertexPositions[ morphIndex + 2 ] += morphPositions[ i * 3 + 2 ];\n\n\t\t}\n\n\t\t// TODO: add morph normal support\n\t\tvar morphGeoInfo = {\n\t\t\tvertexIndices: vertexIndices,\n\t\t\tvertexPositions: vertexPositions,\n\t\t};\n\n\t\tvar morphBuffers = genBuffers( morphGeoInfo );\n\n\t\tvar positionAttribute = new THREE.Float32BufferAttribute( morphBuffers.vertex, 3 );\n\t\tpositionAttribute.name = morphGeoNode.attrName;\n\n\t\tpreTransform.applyToBufferAttribute( positionAttribute );\n\n\t\tparentGeo.morphAttributes.position.push( positionAttribute );\n\n\t}\n\n\t// Parse normal from FBXTree.Objects.Geometry.LayerElementNormal if it exists\n\tfunction getNormals( NormalNode ) {\n\n\t\tvar mappingType = NormalNode.MappingInformationType;\n\t\tvar referenceType = NormalNode.ReferenceInformationType;\n\t\tvar buffer = NormalNode.Normals.a;\n\t\tvar indexBuffer = [];\n\t\tif ( referenceType === 'IndexToDirect' ) {\n\n\t\t\tif ( 'NormalIndex' in NormalNode ) {\n\n\t\t\t\tindexBuffer = NormalNode.NormalIndex.a;\n\n\t\t\t} else if ( 'NormalsIndex' in NormalNode ) {\n\n\t\t\t\tindexBuffer = NormalNode.NormalsIndex.a;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn {\n\t\t\tdataSize: 3,\n\t\t\tbuffer: buffer,\n\t\t\tindices: indexBuffer,\n\t\t\tmappingType: mappingType,\n\t\t\treferenceType: referenceType\n\t\t};\n\n\t}\n\n\t// Parse UVs from FBXTree.Objects.Geometry.LayerElementUV if it exists\n\tfunction getUVs( UVNode ) {\n\n\t\tvar mappingType = UVNode.MappingInformationType;\n\t\tvar referenceType = UVNode.ReferenceInformationType;\n\t\tvar buffer = UVNode.UV.a;\n\t\tvar indexBuffer = [];\n\t\tif ( referenceType === 'IndexToDirect' ) {\n\n\t\t\tindexBuffer = UVNode.UVIndex.a;\n\n\t\t}\n\n\t\treturn {\n\t\t\tdataSize: 2,\n\t\t\tbuffer: buffer,\n\t\t\tindices: indexBuffer,\n\t\t\tmappingType: mappingType,\n\t\t\treferenceType: referenceType\n\t\t};\n\n\t}\n\n\t// Parse Vertex Colors from FBXTree.Objects.Geometry.LayerElementColor if it exists\n\tfunction getColors( ColorNode ) {\n\n\t\tvar mappingType = ColorNode.MappingInformationType;\n\t\tvar referenceType = ColorNode.ReferenceInformationType;\n\t\tvar buffer = ColorNode.Colors.a;\n\t\tvar indexBuffer = [];\n\t\tif ( referenceType === 'IndexToDirect' ) {\n\n\t\t\tindexBuffer = ColorNode.ColorIndex.a;\n\n\t\t}\n\n\t\treturn {\n\t\t\tdataSize: 4,\n\t\t\tbuffer: buffer,\n\t\t\tindices: indexBuffer,\n\t\t\tmappingType: mappingType,\n\t\t\treferenceType: referenceType\n\t\t};\n\n\t}\n\n\t// Parse mapping and material data in FBXTree.Objects.Geometry.LayerElementMaterial if it exists\n\tfunction getMaterials( MaterialNode ) {\n\n\t\tvar mappingType = MaterialNode.MappingInformationType;\n\t\tvar referenceType = MaterialNode.ReferenceInformationType;\n\n\t\tif ( mappingType === 'NoMappingInformation' ) {\n\n\t\t\treturn {\n\t\t\t\tdataSize: 1,\n\t\t\t\tbuffer: [ 0 ],\n\t\t\t\tindices: [ 0 ],\n\t\t\t\tmappingType: 'AllSame',\n\t\t\t\treferenceType: referenceType\n\t\t\t};\n\n\t\t}\n\n\t\tvar materialIndexBuffer = MaterialNode.Materials.a;\n\n\t\t// Since materials are stored as indices, there's a bit of a mismatch between FBX and what\n\t\t// we expect.So we create an intermediate buffer that points to the index in the buffer,\n\t\t// for conforming with the other functions we've written for other data.\n\t\tvar materialIndices = [];\n\n\t\tfor ( var i = 0; i < materialIndexBuffer.length; ++ i ) {\n\n\t\t\tmaterialIndices.push( i );\n\n\t\t}\n\n\t\treturn {\n\t\t\tdataSize: 1,\n\t\t\tbuffer: materialIndexBuffer,\n\t\t\tindices: materialIndices,\n\t\t\tmappingType: mappingType,\n\t\t\treferenceType: referenceType\n\t\t};\n\n\t}\n\n\tvar dataArray = [];\n\n\tfunction getData( polygonVertexIndex, polygonIndex, vertexIndex, infoObject ) {\n\n\t\tvar index;\n\n\t\tswitch ( infoObject.mappingType ) {\n\n\t\t\tcase 'ByPolygonVertex' :\n\t\t\t\tindex = polygonVertexIndex;\n\t\t\t\tbreak;\n\t\t\tcase 'ByPolygon' :\n\t\t\t\tindex = polygonIndex;\n\t\t\t\tbreak;\n\t\t\tcase 'ByVertice' :\n\t\t\t\tindex = vertexIndex;\n\t\t\t\tbreak;\n\t\t\tcase 'AllSame' :\n\t\t\t\tindex = infoObject.indices[ 0 ];\n\t\t\t\tbreak;\n\t\t\tdefault :\n\t\t\t\tconsole.warn( 'THREE.FBXLoader: unknown attribute mapping type ' + infoObject.mappingType );\n\n\t\t}\n\n\t\tif ( infoObject.referenceType === 'IndexToDirect' ) index = infoObject.indices[ index ];\n\n\t\tvar from = index * infoObject.dataSize;\n\t\tvar to = from + infoObject.dataSize;\n\n\t\treturn slice( dataArray, infoObject.buffer, from, to );\n\n\t}\n\n\t// Generate a NurbGeometry from a node in FBXTree.Objects.Geometry\n\tfunction parseNurbsGeometry( geoNode ) {\n\n\t\tif ( THREE.NURBSCurve === undefined ) {\n\n\t\t\tconsole.error( 'THREE.FBXLoader: The loader relies on THREE.NURBSCurve for any nurbs present in the model. Nurbs will show up as empty geometry.' );\n\t\t\treturn new THREE.BufferGeometry();\n\n\t\t}\n\n\t\tvar order = parseInt( geoNode.Order );\n\n\t\tif ( isNaN( order ) ) {\n\n\t\t\tconsole.error( 'THREE.FBXLoader: Invalid Order %s given for geometry ID: %s', geoNode.Order, geoNode.id );\n\t\t\treturn new THREE.BufferGeometry();\n\n\t\t}\n\n\t\tvar degree = order - 1;\n\n\t\tvar knots = geoNode.KnotVector.a;\n\t\tvar controlPoints = [];\n\t\tvar pointsValues = geoNode.Points.a;\n\n\t\tfor ( var i = 0, l = pointsValues.length; i < l; i += 4 ) {\n\n\t\t\tcontrolPoints.push( new THREE.Vector4().fromArray( pointsValues, i ) );\n\n\t\t}\n\n\t\tvar startKnot, endKnot;\n\n\t\tif ( geoNode.Form === 'Closed' ) {\n\n\t\t\tcontrolPoints.push( controlPoints[ 0 ] );\n\n\t\t} else if ( geoNode.Form === 'Periodic' ) {\n\n\t\t\tstartKnot = degree;\n\t\t\tendKnot = knots.length - 1 - startKnot;\n\n\t\t\tfor ( var i = 0; i < degree; ++ i ) {\n\n\t\t\t\tcontrolPoints.push( controlPoints[ i ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar curve = new THREE.NURBSCurve( degree, knots, controlPoints, startKnot, endKnot );\n\t\tvar vertices = curve.getPoints( controlPoints.length * 7 );\n\n\t\tvar positions = new Float32Array( vertices.length * 3 );\n\n\t\tvertices.forEach( function ( vertex, i ) {\n\n\t\t\tvertex.toArray( positions, i * 3 );\n\n\t\t} );\n\n\t\tvar geometry = new THREE.BufferGeometry();\n\t\tgeometry.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );\n\n\t\treturn geometry;\n\n\t}\n\n\t// create the main THREE.Group() to be returned by the loader\n\tfunction parseScene( FBXTree, connections, skeletons, geometryMap, materialMap ) {\n\n\t\tvar sceneGraph = new THREE.Group();\n\n\t\tvar modelMap = parseModels( FBXTree, skeletons, geometryMap, materialMap, connections );\n\n\t\tvar modelNodes = FBXTree.Objects.Model;\n\n\t\tmodelMap.forEach( function ( model ) {\n\n\t\t\tvar modelNode = modelNodes[ model.ID ];\n\t\t\tsetLookAtProperties( FBXTree, model, modelNode, connections, sceneGraph );\n\n\t\t\tvar parentConnections = connections.get( model.ID ).parents;\n\n\t\t\tparentConnections.forEach( function ( connection ) {\n\n\t\t\t\tvar parent = modelMap.get( connection.ID );\n\t\t\t\tif ( parent !== undefined ) parent.add( model );\n\n\t\t\t} );\n\n\t\t\tif ( model.parent === null ) {\n\n\t\t\t\tsceneGraph.add( model );\n\n\t\t\t}\n\n\n\t\t} );\n\n\t\tbindSkeleton( FBXTree, skeletons, geometryMap, modelMap, connections );\n\n\t\taddAnimations( FBXTree, connections, sceneGraph );\n\n\t\tcreateAmbientLight( FBXTree, sceneGraph );\n\n\t\treturn sceneGraph;\n\n\t}\n\n\t// parse nodes in FBXTree.Objects.Model\n\tfunction parseModels( FBXTree, skeletons, geometryMap, materialMap, connections ) {\n\n\t\tvar modelMap = new Map();\n\t\tvar modelNodes = FBXTree.Objects.Model;\n\n\t\tfor ( var nodeID in modelNodes ) {\n\n\t\t\tvar id = parseInt( nodeID );\n\t\t\tvar node = modelNodes[ nodeID ];\n\t\t\tvar relationships = connections.get( id );\n\n\t\t\tvar model = buildSkeleton( relationships, skeletons, id, node.attrName );\n\n\t\t\tif ( ! model ) {\n\n\t\t\t\tswitch ( node.attrType ) {\n\n\t\t\t\t\tcase 'Camera':\n\t\t\t\t\t\tmodel = createCamera( FBXTree, relationships );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'Light':\n\t\t\t\t\t\tmodel = createLight( FBXTree, relationships );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'Mesh':\n\t\t\t\t\t\tmodel = createMesh( FBXTree, relationships, geometryMap, materialMap );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'NurbsCurve':\n\t\t\t\t\t\tmodel = createCurve( relationships, geometryMap );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'LimbNode': // usually associated with a Bone, however if a Bone was not created we'll make a Group instead\n\t\t\t\t\tcase 'Null':\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tmodel = new THREE.Group();\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tmodel.name = THREE.PropertyBinding.sanitizeNodeName( node.attrName );\n\t\t\t\tmodel.ID = id;\n\n\t\t\t}\n\n\t\t\tsetModelTransforms( FBXTree, model, node );\n\t\t\tmodelMap.set( id, model );\n\n\t\t}\n\n\t\treturn modelMap;\n\n\t}\n\n\tfunction buildSkeleton( relationships, skeletons, id, name ) {\n\n\t\tvar bone = null;\n\n\t\trelationships.parents.forEach( function ( parent ) {\n\n\t\t\tfor ( var ID in skeletons ) {\n\n\t\t\t\tvar skeleton = skeletons[ ID ];\n\n\t\t\t\tskeleton.rawBones.forEach( function ( rawBone, i ) {\n\n\t\t\t\t\tif ( rawBone.ID === parent.ID ) {\n\n\t\t\t\t\t\tvar subBone = bone;\n\t\t\t\t\t\tbone = new THREE.Bone();\n\t\t\t\t\t\tbone.matrixWorld.copy( rawBone.transformLink );\n\n\t\t\t\t\t\t// set name and id here - otherwise in cases where \"subBone\" is created it will not have a name / id\n\t\t\t\t\t\tbone.name = THREE.PropertyBinding.sanitizeNodeName( name );\n\t\t\t\t\t\tbone.ID = id;\n\n\t\t\t\t\t\tskeleton.bones[ i ] = bone;\n\n\t\t\t\t\t\t// In cases where a bone is shared between multiple meshes\n\t\t\t\t\t\t// duplicate the bone here and and it as a child of the first bone\n\t\t\t\t\t\tif ( subBone !== null ) {\n\n\t\t\t\t\t\t\tbone.add( subBone );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t} );\n\n\t\treturn bone;\n\n\t}\n\n\t// create a THREE.PerspectiveCamera or THREE.OrthographicCamera\n\tfunction createCamera( FBXTree, relationships ) {\n\n\t\tvar model;\n\t\tvar cameraAttribute;\n\n\t\trelationships.children.forEach( function ( child ) {\n\n\t\t\tvar attr = FBXTree.Objects.NodeAttribute[ child.ID ];\n\n\t\t\tif ( attr !== undefined ) {\n\n\t\t\t\tcameraAttribute = attr;\n\n\t\t\t}\n\n\t\t} );\n\n\t\tif ( cameraAttribute === undefined ) {\n\n\t\t\tmodel = new THREE.Object3D();\n\n\t\t} else {\n\n\t\t\tvar type = 0;\n\t\t\tif ( cameraAttribute.CameraProjectionType !== undefined && cameraAttribute.CameraProjectionType.value === 1 ) {\n\n\t\t\t\ttype = 1;\n\n\t\t\t}\n\n\t\t\tvar nearClippingPlane = 1;\n\t\t\tif ( cameraAttribute.NearPlane !== undefined ) {\n\n\t\t\t\tnearClippingPlane = cameraAttribute.NearPlane.value / 1000;\n\n\t\t\t}\n\n\t\t\tvar farClippingPlane = 1000;\n\t\t\tif ( cameraAttribute.FarPlane !== undefined ) {\n\n\t\t\t\tfarClippingPlane = cameraAttribute.FarPlane.value / 1000;\n\n\t\t\t}\n\n\n\t\t\tvar width = window.innerWidth;\n\t\t\tvar height = window.innerHeight;\n\n\t\t\tif ( cameraAttribute.AspectWidth !== undefined && cameraAttribute.AspectHeight !== undefined ) {\n\n\t\t\t\twidth = cameraAttribute.AspectWidth.value;\n\t\t\t\theight = cameraAttribute.AspectHeight.value;\n\n\t\t\t}\n\n\t\t\tvar aspect = width / height;\n\n\t\t\tvar fov = 45;\n\t\t\tif ( cameraAttribute.FieldOfView !== undefined ) {\n\n\t\t\t\tfov = cameraAttribute.FieldOfView.value;\n\n\t\t\t}\n\n\t\t\tvar focalLength = cameraAttribute.FocalLength ? cameraAttribute.FocalLength.value : null;\n\n\t\t\tswitch ( type ) {\n\n\t\t\t\tcase 0: // Perspective\n\t\t\t\t\tmodel = new THREE.PerspectiveCamera( fov, aspect, nearClippingPlane, farClippingPlane );\n\t\t\t\t\tif ( focalLength !== null ) model.setFocalLength( focalLength );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 1: // Orthographic\n\t\t\t\t\tmodel = new THREE.OrthographicCamera( - width / 2, width / 2, height / 2, - height / 2, nearClippingPlane, farClippingPlane );\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tconsole.warn( 'THREE.FBXLoader: Unknown camera type ' + type + '.' );\n\t\t\t\t\tmodel = new THREE.Object3D();\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn model;\n\n\t}\n\n\t// Create a THREE.DirectionalLight, THREE.PointLight or THREE.SpotLight\n\tfunction createLight( FBXTree, relationships ) {\n\n\t\tvar model;\n\t\tvar lightAttribute;\n\n\t\trelationships.children.forEach( function ( child ) {\n\n\t\t\tvar attr = FBXTree.Objects.NodeAttribute[ child.ID ];\n\n\t\t\tif ( attr !== undefined ) {\n\n\t\t\t\tlightAttribute = attr;\n\n\t\t\t}\n\n\t\t} );\n\n\t\tif ( lightAttribute === undefined ) {\n\n\t\t\tmodel = new THREE.Object3D();\n\n\t\t} else {\n\n\t\t\tvar type;\n\n\t\t\t// LightType can be undefined for Point lights\n\t\t\tif ( lightAttribute.LightType === undefined ) {\n\n\t\t\t\ttype = 0;\n\n\t\t\t} else {\n\n\t\t\t\ttype = lightAttribute.LightType.value;\n\n\t\t\t}\n\n\t\t\tvar color = 0xffffff;\n\n\t\t\tif ( lightAttribute.Color !== undefined ) {\n\n\t\t\t\tcolor = new THREE.Color().fromArray( lightAttribute.Color.value );\n\n\t\t\t}\n\n\t\t\tvar intensity = ( lightAttribute.Intensity === undefined ) ? 1 : lightAttribute.Intensity.value / 100;\n\n\t\t\t// light disabled\n\t\t\tif ( lightAttribute.CastLightOnObject !== undefined && lightAttribute.CastLightOnObject.value === 0 ) {\n\n\t\t\t\tintensity = 0;\n\n\t\t\t}\n\n\t\t\tvar distance = 0;\n\t\t\tif ( lightAttribute.FarAttenuationEnd !== undefined ) {\n\n\t\t\t\tif ( lightAttribute.EnableFarAttenuation !== undefined && lightAttribute.EnableFarAttenuation.value === 0 ) {\n\n\t\t\t\t\tdistance = 0;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tdistance = lightAttribute.FarAttenuationEnd.value;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// TODO: could this be calculated linearly from FarAttenuationStart to FarAttenuationEnd?\n\t\t\tvar decay = 1;\n\n\t\t\tswitch ( type ) {\n\n\t\t\t\tcase 0: // Point\n\t\t\t\t\tmodel = new THREE.PointLight( color, intensity, distance, decay );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 1: // Directional\n\t\t\t\t\tmodel = new THREE.DirectionalLight( color, intensity );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 2: // Spot\n\t\t\t\t\tvar angle = Math.PI / 3;\n\n\t\t\t\t\tif ( lightAttribute.InnerAngle !== undefined ) {\n\n\t\t\t\t\t\tangle = THREE.Math.degToRad( lightAttribute.InnerAngle.value );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar penumbra = 0;\n\t\t\t\t\tif ( lightAttribute.OuterAngle !== undefined ) {\n\n\t\t\t\t\t\t// TODO: this is not correct - FBX calculates outer and inner angle in degrees\n\t\t\t\t\t\t// with OuterAngle > InnerAngle && OuterAngle <= Math.PI\n\t\t\t\t\t\t// while three.js uses a penumbra between (0, 1) to attenuate the inner angle\n\t\t\t\t\t\tpenumbra = THREE.Math.degToRad( lightAttribute.OuterAngle.value );\n\t\t\t\t\t\tpenumbra = Math.max( penumbra, 1 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tmodel = new THREE.SpotLight( color, intensity, distance, angle, penumbra, decay );\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tconsole.warn( 'THREE.FBXLoader: Unknown light type ' + lightAttribute.LightType.value + ', defaulting to a THREE.PointLight.' );\n\t\t\t\t\tmodel = new THREE.PointLight( color, intensity );\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tif ( lightAttribute.CastShadows !== undefined && lightAttribute.CastShadows.value === 1 ) {\n\n\t\t\t\tmodel.castShadow = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn model;\n\n\t}\n\n\tfunction createMesh( FBXTree, relationships, geometryMap, materialMap ) {\n\n\t\tvar model;\n\t\tvar geometry = null;\n\t\tvar material = null;\n\t\tvar materials = [];\n\n\t\t// get geometry and materials(s) from connections\n\t\trelationships.children.forEach( function ( child ) {\n\n\t\t\tif ( geometryMap.has( child.ID ) ) {\n\n\t\t\t\tgeometry = geometryMap.get( child.ID );\n\n\t\t\t}\n\n\t\t\tif ( materialMap.has( child.ID ) ) {\n\n\t\t\t\tmaterials.push( materialMap.get( child.ID ) );\n\n\t\t\t}\n\n\t\t} );\n\n\t\tif ( materials.length > 1 ) {\n\n\t\t\tmaterial = materials;\n\n\t\t} else if ( materials.length > 0 ) {\n\n\t\t\tmaterial = materials[ 0 ];\n\n\t\t} else {\n\n\t\t\tmaterial = new THREE.MeshPhongMaterial( { color: 0xcccccc } );\n\t\t\tmaterials.push( material );\n\n\t\t}\n\n\t\tif ( 'color' in geometry.attributes ) {\n\n\t\t\tmaterials.forEach( function ( material ) {\n\n\t\t\t\tmaterial.vertexColors = THREE.VertexColors;\n\n\t\t\t} );\n\n\t\t}\n\n\t\tif ( geometry.FBX_Deformer ) {\n\n\t\t\tmaterials.forEach( function ( material ) {\n\n\t\t\t\tmaterial.skinning = true;\n\n\t\t\t} );\n\n\t\t\tmodel = new THREE.SkinnedMesh( geometry, material );\n\n\t\t} else {\n\n\t\t\tmodel = new THREE.Mesh( geometry, material );\n\n\t\t}\n\n\t\treturn model;\n\n\t}\n\n\tfunction createCurve( relationships, geometryMap ) {\n\n\t\tvar geometry = relationships.children.reduce( function ( geo, child ) {\n\n\t\t\tif ( geometryMap.has( child.ID ) ) geo = geometryMap.get( child.ID );\n\n\t\t\treturn geo;\n\n\t\t}, null );\n\n\t\t// FBX does not list materials for Nurbs lines, so we'll just put our own in here.\n\t\tvar material = new THREE.LineBasicMaterial( { color: 0x3300ff, linewidth: 1 } );\n\t\treturn new THREE.Line( geometry, material );\n\n\t}\n\n\t// Parse ambient color in FBXTree.GlobalSettings - if it's not set to black (default), create an ambient light\n\tfunction createAmbientLight( FBXTree, sceneGraph ) {\n\n\t\tif ( 'GlobalSettings' in FBXTree && 'AmbientColor' in FBXTree.GlobalSettings ) {\n\n\t\t\tvar ambientColor = FBXTree.GlobalSettings.AmbientColor.value;\n\t\t\tvar r = ambientColor[ 0 ];\n\t\t\tvar g = ambientColor[ 1 ];\n\t\t\tvar b = ambientColor[ 2 ];\n\n\t\t\tif ( r !== 0 || g !== 0 || b !== 0 ) {\n\n\t\t\t\tvar color = new THREE.Color( r, g, b );\n\t\t\t\tsceneGraph.add( new THREE.AmbientLight( color, 1 ) );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tfunction setLookAtProperties( FBXTree, model, modelNode, connections, sceneGraph ) {\n\n\t\tif ( 'LookAtProperty' in modelNode ) {\n\n\t\t\tvar children = connections.get( model.ID ).children;\n\n\t\t\tchildren.forEach( function ( child ) {\n\n\t\t\t\tif ( child.relationship === 'LookAtProperty' ) {\n\n\t\t\t\t\tvar lookAtTarget = FBXTree.Objects.Model[ child.ID ];\n\n\t\t\t\t\tif ( 'Lcl_Translation' in lookAtTarget ) {\n\n\t\t\t\t\t\tvar pos = lookAtTarget.Lcl_Translation.value;\n\n\t\t\t\t\t\t// DirectionalLight, SpotLight\n\t\t\t\t\t\tif ( model.target !== undefined ) {\n\n\t\t\t\t\t\t\tmodel.target.position.fromArray( pos );\n\t\t\t\t\t\t\tsceneGraph.add( model.target );\n\n\t\t\t\t\t\t} else { // Cameras and other Object3Ds\n\n\t\t\t\t\t\t\tmodel.lookAt( new THREE.Vector3().fromArray( pos ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t}\n\n\t}\n\n\t// parse the model node for transform details and apply them to the model\n\tfunction setModelTransforms( FBXTree, model, modelNode ) {\n\n\t\t// http://help.autodesk.com/view/FBX/2017/ENU/?guid=__cpp_ref_class_fbx_euler_html\n\t\tif ( 'RotationOrder' in modelNode ) {\n\n\t\t\tvar enums = [\n\t\t\t\t'XYZ', // default\n\t\t\t\t'XZY',\n\t\t\t\t'YZX',\n\t\t\t\t'ZXY',\n\t\t\t\t'YXZ',\n\t\t\t\t'ZYX',\n\t\t\t\t'SphericXYZ',\n\t\t\t];\n\n\t\t\tvar value = parseInt( modelNode.RotationOrder.value, 10 );\n\n\t\t\tif ( value > 0 && value < 6 ) {\n\n\t\t\t\t// model.rotation.order = enums[ value ];\n\n\t\t\t\t// Note: Euler order other than XYZ is currently not supported, so just display a warning for now\n\t\t\t\tconsole.warn( 'THREE.FBXLoader: unsupported Euler Order: %s. Currently only XYZ order is supported. Animations and rotations may be incorrect.', enums[ value ] );\n\n\t\t\t} else if ( value === 6 ) {\n\n\t\t\t\tconsole.warn( 'THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect.' );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( 'Lcl_Translation' in modelNode ) {\n\n\t\t\tmodel.position.fromArray( modelNode.Lcl_Translation.value );\n\n\t\t}\n\n\t\tif ( 'Lcl_Rotation' in modelNode ) {\n\n\t\t\tvar rotation = modelNode.Lcl_Rotation.value.map( THREE.Math.degToRad );\n\t\t\trotation.push( 'ZYX' );\n\t\t\tmodel.quaternion.setFromEuler( new THREE.Euler().fromArray( rotation ) );\n\n\t\t}\n\n\t\tif ( 'Lcl_Scaling' in modelNode ) {\n\n\t\t\tmodel.scale.fromArray( modelNode.Lcl_Scaling.value );\n\n\t\t}\n\n\t\tif ( 'PreRotation' in modelNode ) {\n\n\t\t\tvar array = modelNode.PreRotation.value.map( THREE.Math.degToRad );\n\t\t\tarray[ 3 ] = 'ZYX';\n\n\t\t\tvar preRotations = new THREE.Euler().fromArray( array );\n\n\t\t\tpreRotations = new THREE.Quaternion().setFromEuler( preRotations );\n\t\t\tmodel.quaternion.premultiply( preRotations );\n\n\t\t}\n\n\t}\n\n\tfunction bindSkeleton( FBXTree, skeletons, geometryMap, modelMap, connections ) {\n\n\t\tvar bindMatrices = parsePoseNodes( FBXTree );\n\n\t\tfor ( var ID in skeletons ) {\n\n\t\t\tvar skeleton = skeletons[ ID ];\n\n\t\t\tvar parents = connections.get( parseInt( skeleton.ID ) ).parents;\n\n\t\t\tparents.forEach( function ( parent ) {\n\n\t\t\t\tif ( geometryMap.has( parent.ID ) ) {\n\n\t\t\t\t\tvar geoID = parent.ID;\n\t\t\t\t\tvar geoRelationships = connections.get( geoID );\n\n\t\t\t\t\tgeoRelationships.parents.forEach( function ( geoConnParent ) {\n\n\t\t\t\t\t\tif ( modelMap.has( geoConnParent.ID ) ) {\n\n\t\t\t\t\t\t\tvar model = modelMap.get( geoConnParent.ID );\n\n\t\t\t\t\t\t\tmodel.bind( new THREE.Skeleton( skeleton.bones ), bindMatrices[ geoConnParent.ID ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t}\n\n\t}\n\n\tfunction parsePoseNodes( FBXTree ) {\n\n\t\tvar bindMatrices = {};\n\n\t\tif ( 'Pose' in FBXTree.Objects ) {\n\n\t\t\tvar BindPoseNode = FBXTree.Objects.Pose;\n\n\t\t\tfor ( var nodeID in BindPoseNode ) {\n\n\t\t\t\tif ( BindPoseNode[ nodeID ].attrType === 'BindPose' ) {\n\n\t\t\t\t\tvar poseNodes = BindPoseNode[ nodeID ].PoseNode;\n\n\t\t\t\t\tif ( Array.isArray( poseNodes ) ) {\n\n\t\t\t\t\t\tposeNodes.forEach( function ( poseNode ) {\n\n\t\t\t\t\t\t\tbindMatrices[ poseNode.Node ] = new THREE.Matrix4().fromArray( poseNode.Matrix.a );\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tbindMatrices[ poseNodes.Node ] = new THREE.Matrix4().fromArray( poseNodes.Matrix.a );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn bindMatrices;\n\n\t}\n\n\tfunction parseAnimations( FBXTree, connections ) {\n\n\t\t// since the actual transformation data is stored in FBXTree.Objects.AnimationCurve,\n\t\t// if this is undefined we can safely assume there are no animations\n\t\tif ( FBXTree.Objects.AnimationCurve === undefined ) return undefined;\n\n\t\tvar curveNodesMap = parseAnimationCurveNodes( FBXTree );\n\n\t\tparseAnimationCurves( FBXTree, connections, curveNodesMap );\n\n\t\tvar layersMap = parseAnimationLayers( FBXTree, connections, curveNodesMap );\n\t\tvar rawClips = parseAnimStacks( FBXTree, connections, layersMap );\n\n\t\treturn rawClips;\n\n\t}\n\n\t// parse nodes in FBXTree.Objects.AnimationCurveNode\n\t// each AnimationCurveNode holds data for an animation transform for a model (e.g. left arm rotation )\n\t// and is referenced by an AnimationLayer\n\tfunction parseAnimationCurveNodes( FBXTree ) {\n\n\t\tvar rawCurveNodes = FBXTree.Objects.AnimationCurveNode;\n\n\t\tvar curveNodesMap = new Map();\n\n\t\tfor ( var nodeID in rawCurveNodes ) {\n\n\t\t\tvar rawCurveNode = rawCurveNodes[ nodeID ];\n\n\t\t\tif ( rawCurveNode.attrName.match( /S|R|T/ ) !== null ) {\n\n\t\t\t\tvar curveNode = {\n\n\t\t\t\t\tid: rawCurveNode.id,\n\t\t\t\t\tattr: rawCurveNode.attrName,\n\t\t\t\t\tcurves: {},\n\n\t\t\t\t};\n\n\t\t\t\tcurveNodesMap.set( curveNode.id, curveNode );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn curveNodesMap;\n\n\t}\n\n\t// parse nodes in FBXTree.Objects.AnimationCurve and connect them up to\n\t// previously parsed AnimationCurveNodes. Each AnimationCurve holds data for a single animated\n\t// axis ( e.g. times and values of x rotation)\n\tfunction parseAnimationCurves( FBXTree, connections, curveNodesMap ) {\n\n\t\tvar rawCurves = FBXTree.Objects.AnimationCurve;\n\n\t\tfor ( var nodeID in rawCurves ) {\n\n\t\t\tvar animationCurve = {\n\n\t\t\t\tid: rawCurves[ nodeID ].id,\n\t\t\t\ttimes: rawCurves[ nodeID ].KeyTime.a.map( convertFBXTimeToSeconds ),\n\t\t\t\tvalues: rawCurves[ nodeID ].KeyValueFloat.a,\n\n\t\t\t};\n\n\t\t\tvar relationships = connections.get( animationCurve.id );\n\n\t\t\tif ( relationships !== undefined ) {\n\n\t\t\t\tvar animationCurveID = relationships.parents[ 0 ].ID;\n\t\t\t\tvar animationCurveRelationship = relationships.parents[ 0 ].relationship;\n\n\t\t\t\tif ( animationCurveRelationship.match( /X/ ) ) {\n\n\t\t\t\t\tcurveNodesMap.get( animationCurveID ).curves[ 'x' ] = animationCurve;\n\n\t\t\t\t} else if ( animationCurveRelationship.match( /Y/ ) ) {\n\n\t\t\t\t\tcurveNodesMap.get( animationCurveID ).curves[ 'y' ] = animationCurve;\n\n\t\t\t\t} else if ( animationCurveRelationship.match( /Z/ ) ) {\n\n\t\t\t\t\tcurveNodesMap.get( animationCurveID ).curves[ 'z' ] = animationCurve;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// parse nodes in FBXTree.Objects.AnimationLayer. Each layers holds references\n\t// to various AnimationCurveNodes and is referenced by an AnimationStack node\n\t// note: theoretically a stack can have multiple layers, however in practice there always seems to be one per stack\n\tfunction parseAnimationLayers( FBXTree, connections, curveNodesMap ) {\n\n\t\tvar rawLayers = FBXTree.Objects.AnimationLayer;\n\n\t\tvar layersMap = new Map();\n\n\t\tfor ( var nodeID in rawLayers ) {\n\n\t\t\tvar layerCurveNodes = [];\n\n\t\t\tvar connection = connections.get( parseInt( nodeID ) );\n\n\t\t\tif ( connection !== undefined ) {\n\n\t\t\t\t// all the animationCurveNodes used in the layer\n\t\t\t\tvar children = connection.children;\n\n\t\t\t\tchildren.forEach( function ( child, i ) {\n\n\t\t\t\t\tif ( curveNodesMap.has( child.ID ) ) {\n\n\t\t\t\t\t\tvar curveNode = curveNodesMap.get( child.ID );\n\n\t\t\t\t\t\t// check that the curves are defined for at least one axis, otherwise ignore the curveNode\n\t\t\t\t\t\tif ( curveNode.curves.x !== undefined || curveNode.curves.y !== undefined || curveNode.curves.z !== undefined ) {\n\n\t\t\t\t\t\t\tif ( layerCurveNodes[ i ] === undefined ) {\n\n\t\t\t\t\t\t\t\tvar modelID;\n\n\t\t\t\t\t\t\t\tconnections.get( child.ID ).parents.forEach( function ( parent ) {\n\n\t\t\t\t\t\t\t\t\tif ( parent.relationship !== undefined ) modelID = parent.ID;\n\n\t\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t\t\tvar rawModel = FBXTree.Objects.Model[ modelID.toString() ];\n\n\t\t\t\t\t\t\t\tvar node = {\n\n\t\t\t\t\t\t\t\t\tmodelName: THREE.PropertyBinding.sanitizeNodeName( rawModel.attrName ),\n\t\t\t\t\t\t\t\t\tinitialPosition: [ 0, 0, 0 ],\n\t\t\t\t\t\t\t\t\tinitialRotation: [ 0, 0, 0 ],\n\t\t\t\t\t\t\t\t\tinitialScale: [ 1, 1, 1 ],\n\n\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t\tif ( 'Lcl_Translation' in rawModel ) node.initialPosition = rawModel.Lcl_Translation.value;\n\n\t\t\t\t\t\t\t\tif ( 'Lcl_Rotation' in rawModel ) node.initialRotation = rawModel.Lcl_Rotation.value;\n\n\t\t\t\t\t\t\t\tif ( 'Lcl_Scaling' in rawModel ) node.initialScale = rawModel.Lcl_Scaling.value;\n\n\t\t\t\t\t\t\t\t// if the animated model is pre rotated, we'll have to apply the pre rotations to every\n\t\t\t\t\t\t\t\t// animation value as well\n\t\t\t\t\t\t\t\tif ( 'PreRotation' in rawModel ) node.preRotations = rawModel.PreRotation.value;\n\n\t\t\t\t\t\t\t\tlayerCurveNodes[ i ] = node;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tlayerCurveNodes[ i ][ curveNode.attr ] = curveNode;\n\n\t\t\t\t\t\t}\n\n\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\tlayersMap.set( parseInt( nodeID ), layerCurveNodes );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn layersMap;\n\n\t}\n\n\t// parse nodes in FBXTree.Objects.AnimationStack. These are the top level node in the animation\n\t// hierarchy. Each Stack node will be used to create a THREE.AnimationClip\n\tfunction parseAnimStacks( FBXTree, connections, layersMap ) {\n\n\t\tvar rawStacks = FBXTree.Objects.AnimationStack;\n\n\t\t// connect the stacks (clips) up to the layers\n\t\tvar rawClips = {};\n\n\t\tfor ( var nodeID in rawStacks ) {\n\n\t\t\tvar children = connections.get( parseInt( nodeID ) ).children;\n\n\t\t\tif ( children.length > 1 ) {\n\n\t\t\t\t// it seems like stacks will always be associated with a single layer. But just in case there are files\n\t\t\t\t// where there are multiple layers per stack, we'll display a warning\n\t\t\t\tconsole.warn( 'THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers.' );\n\n\t\t\t}\n\n\t\t\tvar layer = layersMap.get( children[ 0 ].ID );\n\n\t\t\trawClips[ nodeID ] = {\n\n\t\t\t\tname: rawStacks[ nodeID ].attrName,\n\t\t\t\tlayer: layer,\n\n\t\t\t};\n\n\t\t}\n\n\t\treturn rawClips;\n\n\t}\n\n\t// take raw animation data from parseAnimations and connect it up to the loaded models\n\tfunction addAnimations( FBXTree, connections, sceneGraph ) {\n\n\t\tsceneGraph.animations = [];\n\n\t\tvar rawClips = parseAnimations( FBXTree, connections );\n\n\t\tif ( rawClips === undefined ) return;\n\n\n\t\tfor ( var key in rawClips ) {\n\n\t\t\tvar rawClip = rawClips[ key ];\n\n\t\t\tvar clip = addClip( rawClip );\n\n\t\t\tsceneGraph.animations.push( clip );\n\n\t\t}\n\n\t}\n\n\tfunction addClip( rawClip ) {\n\n\t\tvar tracks = [];\n\n\t\trawClip.layer.forEach( function ( rawTracks ) {\n\n\t\t\ttracks = tracks.concat( generateTracks( rawTracks ) );\n\n\t\t} );\n\n\t\treturn new THREE.AnimationClip( rawClip.name, - 1, tracks );\n\n\t}\n\n\tfunction generateTracks( rawTracks ) {\n\n\t\tvar tracks = [];\n\n\t\tif ( rawTracks.T !== undefined && Object.keys( rawTracks.T.curves ).length > 0 ) {\n\n\t\t\tvar positionTrack = generateVectorTrack( rawTracks.modelName, rawTracks.T.curves, rawTracks.initialPosition, 'position' );\n\t\t\tif ( positionTrack !== undefined ) tracks.push( positionTrack );\n\n\t\t}\n\n\t\tif ( rawTracks.R !== undefined && Object.keys( rawTracks.R.curves ).length > 0 ) {\n\n\t\t\tvar rotationTrack = generateRotationTrack( rawTracks.modelName, rawTracks.R.curves, rawTracks.initialRotation, rawTracks.preRotations );\n\t\t\tif ( rotationTrack !== undefined ) tracks.push( rotationTrack );\n\n\t\t}\n\n\t\tif ( rawTracks.S !== undefined && Object.keys( rawTracks.S.curves ).length > 0 ) {\n\n\t\t\tvar scaleTrack = generateVectorTrack( rawTracks.modelName, rawTracks.S.curves, rawTracks.initialScale, 'scale' );\n\t\t\tif ( scaleTrack !== undefined ) tracks.push( scaleTrack );\n\n\t\t}\n\n\t\treturn tracks;\n\n\t}\n\n\tfunction generateVectorTrack( modelName, curves, initialValue, type ) {\n\n\t\tvar times = getTimesForAllAxes( curves );\n\t\tvar values = getKeyframeTrackValues( times, curves, initialValue );\n\n\t\treturn new THREE.VectorKeyframeTrack( modelName + '.' + type, times, values );\n\n\t}\n\n\tfunction generateRotationTrack( modelName, curves, initialValue, preRotations ) {\n\n\t\tif ( curves.x !== undefined ) {\n\n\t\t\tinterpolateRotations( curves.x );\n\t\t\tcurves.x.values = curves.x.values.map( THREE.Math.degToRad );\n\n\t\t}\n\t\tif ( curves.y !== undefined ) {\n\n\t\t\tinterpolateRotations( curves.y );\n\t\t\tcurves.y.values = curves.y.values.map( THREE.Math.degToRad );\n\n\t\t}\n\t\tif ( curves.z !== undefined ) {\n\n\t\t\tinterpolateRotations( curves.z );\n\t\t\tcurves.z.values = curves.z.values.map( THREE.Math.degToRad );\n\n\t\t}\n\n\t\tvar times = getTimesForAllAxes( curves );\n\t\tvar values = getKeyframeTrackValues( times, curves, initialValue );\n\n\t\tif ( preRotations !== undefined ) {\n\n\t\t\tpreRotations = preRotations.map( THREE.Math.degToRad );\n\t\t\tpreRotations.push( 'ZYX' );\n\n\t\t\tpreRotations = new THREE.Euler().fromArray( preRotations );\n\t\t\tpreRotations = new THREE.Quaternion().setFromEuler( preRotations );\n\n\t\t}\n\n\t\tvar quaternion = new THREE.Quaternion();\n\t\tvar euler = new THREE.Euler();\n\n\t\tvar quaternionValues = [];\n\n\t\tfor ( var i = 0; i < values.length; i += 3 ) {\n\n\t\t\teuler.set( values[ i ], values[ i + 1 ], values[ i + 2 ], 'ZYX' );\n\n\t\t\tquaternion.setFromEuler( euler );\n\n\t\t\tif ( preRotations !== undefined )quaternion.premultiply( preRotations );\n\n\t\t\tquaternion.toArray( quaternionValues, ( i / 3 ) * 4 );\n\n\t\t}\n\n\t\treturn new THREE.QuaternionKeyframeTrack( modelName + '.quaternion', times, quaternionValues );\n\n\t}\n\n\tfunction getKeyframeTrackValues( times, curves, initialValue ) {\n\n\t\tvar prevValue = initialValue;\n\n\t\tvar values = [];\n\n\t\tvar xIndex = - 1;\n\t\tvar yIndex = - 1;\n\t\tvar zIndex = - 1;\n\n\t\ttimes.forEach( function ( time ) {\n\n\t\t\tif ( curves.x ) xIndex = curves.x.times.indexOf( time );\n\t\t\tif ( curves.y ) yIndex = curves.y.times.indexOf( time );\n\t\t\tif ( curves.z ) zIndex = curves.z.times.indexOf( time );\n\n\t\t\t// if there is an x value defined for this frame, use that\n\t\t\tif ( xIndex !== - 1 ) {\n\n\t\t\t\tvar xValue = curves.x.values[ xIndex ];\n\t\t\t\tvalues.push( xValue );\n\t\t\t\tprevValue[ 0 ] = xValue;\n\n\t\t\t} else {\n\n\t\t\t\t// otherwise use the x value from the previous frame\n\t\t\t\tvalues.push( prevValue[ 0 ] );\n\n\t\t\t}\n\n\t\t\tif ( yIndex !== - 1 ) {\n\n\t\t\t\tvar yValue = curves.y.values[ yIndex ];\n\t\t\t\tvalues.push( yValue );\n\t\t\t\tprevValue[ 1 ] = yValue;\n\n\t\t\t} else {\n\n\t\t\t\tvalues.push( prevValue[ 1 ] );\n\n\t\t\t}\n\n\t\t\tif ( zIndex !== - 1 ) {\n\n\t\t\t\tvar zValue = curves.z.values[ zIndex ];\n\t\t\t\tvalues.push( zValue );\n\t\t\t\tprevValue[ 2 ] = zValue;\n\n\t\t\t} else {\n\n\t\t\t\tvalues.push( prevValue[ 2 ] );\n\n\t\t\t}\n\n\t\t} );\n\n\t\treturn values;\n\n\t}\n\n\t// For all animated objects, times are defined separately for each axis\n\t// Here we'll combine the times into one sorted array without duplicates\n\tfunction getTimesForAllAxes( curves ) {\n\n\t\tvar times = [];\n\n\t\t// first join together the times for each axis, if defined\n\t\tif ( curves.x !== undefined ) times = times.concat( curves.x.times );\n\t\tif ( curves.y !== undefined ) times = times.concat( curves.y.times );\n\t\tif ( curves.z !== undefined ) times = times.concat( curves.z.times );\n\n\t\t// then sort them and remove duplicates\n\t\ttimes = times.sort( function ( a, b ) {\n\n\t\t\treturn a - b;\n\n\t\t} ).filter( function ( elem, index, array ) {\n\n\t\t\treturn array.indexOf( elem ) == index;\n\n\t\t} );\n\n\t\treturn times;\n\n\t}\n\n\t// Rotations are defined as Euler angles which can have values  of any size\n\t// These will be converted to quaternions which don't support values greater than\n\t// PI, so we'll interpolate large rotations\n\tfunction interpolateRotations( curve ) {\n\n\t\tfor ( var i = 1; i < curve.values.length; i ++ ) {\n\n\t\t\tvar initialValue = curve.values[ i - 1 ];\n\t\t\tvar valuesSpan = curve.values[ i ] - initialValue;\n\n\t\t\tvar absoluteSpan = Math.abs( valuesSpan );\n\n\t\t\tif ( absoluteSpan >= 180 ) {\n\n\t\t\t\tvar numSubIntervals = absoluteSpan / 180;\n\n\t\t\t\tvar step = valuesSpan / numSubIntervals;\n\t\t\t\tvar nextValue = initialValue + step;\n\n\t\t\t\tvar initialTime = curve.times[ i - 1 ];\n\t\t\t\tvar timeSpan = curve.times[ i ] - initialTime;\n\t\t\t\tvar interval = timeSpan / numSubIntervals;\n\t\t\t\tvar nextTime = initialTime + interval;\n\n\t\t\t\tvar interpolatedTimes = [];\n\t\t\t\tvar interpolatedValues = [];\n\n\t\t\t\twhile ( nextTime < curve.times[ i ] ) {\n\n\t\t\t\t\tinterpolatedTimes.push( nextTime );\n\t\t\t\t\tnextTime += interval;\n\n\t\t\t\t\tinterpolatedValues.push( nextValue );\n\t\t\t\t\tnextValue += step;\n\n\t\t\t\t}\n\n\t\t\t\tcurve.times = inject( curve.times, i, interpolatedTimes );\n\t\t\t\tcurve.values = inject( curve.values, i, interpolatedValues );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// parse an FBX file in ASCII format\n\tfunction TextParser() {}\n\n\tObject.assign( TextParser.prototype, {\n\n\t\tgetPrevNode: function () {\n\n\t\t\treturn this.nodeStack[ this.currentIndent - 2 ];\n\n\t\t},\n\n\t\tgetCurrentNode: function () {\n\n\t\t\treturn this.nodeStack[ this.currentIndent - 1 ];\n\n\t\t},\n\n\t\tgetCurrentProp: function () {\n\n\t\t\treturn this.currentProp;\n\n\t\t},\n\n\t\tpushStack: function ( node ) {\n\n\t\t\tthis.nodeStack.push( node );\n\t\t\tthis.currentIndent += 1;\n\n\t\t},\n\n\t\tpopStack: function () {\n\n\t\t\tthis.nodeStack.pop();\n\t\t\tthis.currentIndent -= 1;\n\n\t\t},\n\n\t\tsetCurrentProp: function ( val, name ) {\n\n\t\t\tthis.currentProp = val;\n\t\t\tthis.currentPropName = name;\n\n\t\t},\n\n\t\tparse: function ( text ) {\n\n\t\t\tthis.currentIndent = 0;\n\t\t\tthis.allNodes = new FBXTree();\n\t\t\tthis.nodeStack = [];\n\t\t\tthis.currentProp = [];\n\t\t\tthis.currentPropName = '';\n\n\t\t\tvar self = this;\n\n\t\t\tvar split = text.split( '\\n' );\n\n\t\t\tsplit.forEach( function ( line, i ) {\n\n\t\t\t\tvar matchComment = line.match( /^[\\s\\t]*;/ );\n\t\t\t\tvar matchEmpty = line.match( /^[\\s\\t]*$/ );\n\n\t\t\t\tif ( matchComment || matchEmpty ) return;\n\n\t\t\t\tvar matchBeginning = line.match( '^\\\\t{' + self.currentIndent + '}(\\\\w+):(.*){', '' );\n\t\t\t\tvar matchProperty = line.match( '^\\\\t{' + ( self.currentIndent ) + '}(\\\\w+):[\\\\s\\\\t\\\\r\\\\n](.*)' );\n\t\t\t\tvar matchEnd = line.match( '^\\\\t{' + ( self.currentIndent - 1 ) + '}}' );\n\n\t\t\t\tif ( matchBeginning ) {\n\n\t\t\t\t\tself.parseNodeBegin( line, matchBeginning );\n\n\t\t\t\t} else if ( matchProperty ) {\n\n\t\t\t\t\tself.parseNodeProperty( line, matchProperty, split[ ++ i ] );\n\n\t\t\t\t} else if ( matchEnd ) {\n\n\t\t\t\t\tself.popStack();\n\n\t\t\t\t} else if ( line.match( /^[^\\s\\t}]/ ) ) {\n\n\t\t\t\t\t// large arrays are split over multiple lines terminated with a ',' character\n\t\t\t\t\t// if this is encountered the line needs to be joined to the previous line\n\t\t\t\t\tself.parseNodePropertyContinued( line );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\treturn this.allNodes;\n\n\t\t},\n\n\t\tparseNodeBegin: function ( line, property ) {\n\n\t\t\tvar nodeName = property[ 1 ].trim().replace( /^\"/, '' ).replace( /\"$/, '' );\n\n\t\t\tvar nodeAttrs = property[ 2 ].split( ',' ).map( function ( attr ) {\n\n\t\t\t\treturn attr.trim().replace( /^\"/, '' ).replace( /\"$/, '' );\n\n\t\t\t} );\n\n\t\t\tvar node = { name: nodeName };\n\t\t\tvar attrs = this.parseNodeAttr( nodeAttrs );\n\n\t\t\tvar currentNode = this.getCurrentNode();\n\n\t\t\t// a top node\n\t\t\tif ( this.currentIndent === 0 ) {\n\n\t\t\t\tthis.allNodes.add( nodeName, node );\n\n\t\t\t} else { // a subnode\n\n\t\t\t\t// if the subnode already exists, append it\n\t\t\t\tif ( nodeName in currentNode ) {\n\n\t\t\t\t// special case Pose needs PoseNodes as an array\n\t\t\t\t\tif ( nodeName === 'PoseNode' ) {\n\n\t\t\t\t\t\tcurrentNode.PoseNode.push( node );\n\n\t\t\t\t\t} else if ( currentNode[ nodeName ].id !== undefined ) {\n\n\t\t\t\t\t\tcurrentNode[ nodeName ] = {};\n\t\t\t\t\t\tcurrentNode[ nodeName ][ currentNode[ nodeName ].id ] = currentNode[ nodeName ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( attrs.id !== '' ) currentNode[ nodeName ][ attrs.id ] = node;\n\n\t\t\t\t} else if ( typeof attrs.id === 'number' ) {\n\n\t\t\t\t\tcurrentNode[ nodeName ] = {};\n\t\t\t\t\tcurrentNode[ nodeName ][ attrs.id ] = node;\n\n\t\t\t\t} else if ( nodeName !== 'Properties70' ) {\n\n\t\t\t\t\tif ( nodeName === 'PoseNode' )\tcurrentNode[ nodeName ] = [ node ];\n\t\t\t\t\telse currentNode[ nodeName ] = node;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( typeof attrs.id === 'number' ) node.id = attrs.id;\n\t\t\tif ( attrs.name !== '' ) node.attrName = attrs.name;\n\t\t\tif ( attrs.type !== '' ) node.attrType = attrs.type;\n\n\t\t\tthis.pushStack( node );\n\n\t\t},\n\n\t\tparseNodeAttr: function ( attrs ) {\n\n\t\t\tvar id = attrs[ 0 ];\n\n\t\t\tif ( attrs[ 0 ] !== '' ) {\n\n\t\t\t\tid = parseInt( attrs[ 0 ] );\n\n\t\t\t\tif ( isNaN( id ) ) {\n\n\t\t\t\t\tid = attrs[ 0 ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar name = '', type = '';\n\n\t\t\tif ( attrs.length > 1 ) {\n\n\t\t\t\tname = attrs[ 1 ].replace( /^(\\w+)::/, '' );\n\t\t\t\ttype = attrs[ 2 ];\n\n\t\t\t}\n\n\t\t\treturn { id: id, name: name, type: type };\n\n\t\t},\n\n\t\tparseNodeProperty: function ( line, property, contentLine ) {\n\n\t\t\tvar propName = property[ 1 ].replace( /^\"/, '' ).replace( /\"$/, '' ).trim();\n\t\t\tvar propValue = property[ 2 ].replace( /^\"/, '' ).replace( /\"$/, '' ).trim();\n\n\t\t\t// for special case: base64 image data follows \"Content: ,\" line\n\t\t\t//\tContent: ,\n\t\t\t//\t \"/9j/4RDaRXhpZgAATU0A...\"\n\t\t\tif ( propName === 'Content' && propValue === ',' ) {\n\n\t\t\t\tpropValue = contentLine.replace( /\"/g, '' ).replace( /,$/, '' ).trim();\n\n\t\t\t}\n\n\t\t\tvar currentNode = this.getCurrentNode();\n\t\t\tvar parentName = currentNode.name;\n\n\t\t\tif ( parentName === 'Properties70' ) {\n\n\t\t\t\tthis.parseNodeSpecialProperty( line, propName, propValue );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\t// Connections\n\t\t\tif ( propName === 'C' ) {\n\n\t\t\t\tvar connProps = propValue.split( ',' ).slice( 1 );\n\t\t\t\tvar from = parseInt( connProps[ 0 ] );\n\t\t\t\tvar to = parseInt( connProps[ 1 ] );\n\n\t\t\t\tvar rest = propValue.split( ',' ).slice( 3 );\n\n\t\t\t\trest = rest.map( function ( elem ) {\n\n\t\t\t\t\treturn elem.trim().replace( /^\"/, '' );\n\n\t\t\t\t} );\n\n\t\t\t\tpropName = 'connections';\n\t\t\t\tpropValue = [ from, to ];\n\t\t\t\tappend( propValue, rest );\n\n\t\t\t\tif ( currentNode[ propName ] === undefined ) {\n\n\t\t\t\t\tcurrentNode[ propName ] = [];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Node\n\t\t\tif ( propName === 'Node' ) currentNode.id = propValue;\n\n\t\t\t// connections\n\t\t\tif ( propName in currentNode && Array.isArray( currentNode[ propName ] ) ) {\n\n\t\t\t\tcurrentNode[ propName ].push( propValue );\n\n\t\t\t} else {\n\n\t\t\t\tif ( propName !== 'a' ) currentNode[ propName ] = propValue;\n\t\t\t\telse currentNode.a = propValue;\n\n\t\t\t}\n\n\t\t\tthis.setCurrentProp( currentNode, propName );\n\n\t\t\t// convert string to array, unless it ends in ',' in which case more will be added to it\n\t\t\tif ( propName === 'a' && propValue.slice( - 1 ) !== ',' ) {\n\n\t\t\t\tcurrentNode.a = parseNumberArray( propValue );\n\n\t\t\t}\n\n\t\t},\n\n\t\tparseNodePropertyContinued: function ( line ) {\n\n\t\t\tvar currentNode = this.getCurrentNode();\n\n\t\t\tcurrentNode.a += line;\n\n\t\t\t// if the line doesn't end in ',' we have reached the end of the property value\n\t\t\t// so convert the string to an array\n\t\t\tif ( line.slice( - 1 ) !== ',' ) {\n\n\t\t\t\tcurrentNode.a = parseNumberArray( currentNode.a );\n\n\t\t\t}\n\n\t\t},\n\n\t\t// parse \"Property70\"\n\t\tparseNodeSpecialProperty: function ( line, propName, propValue ) {\n\n\t\t\t// split this\n\t\t\t// P: \"Lcl Scaling\", \"Lcl Scaling\", \"\", \"A\",1,1,1\n\t\t\t// into array like below\n\t\t\t// [\"Lcl Scaling\", \"Lcl Scaling\", \"\", \"A\", \"1,1,1\" ]\n\t\t\tvar props = propValue.split( '\",' ).map( function ( prop ) {\n\n\t\t\t\treturn prop.trim().replace( /^\\\"/, '' ).replace( /\\s/, '_' );\n\n\t\t\t} );\n\n\t\t\tvar innerPropName = props[ 0 ];\n\t\t\tvar innerPropType1 = props[ 1 ];\n\t\t\tvar innerPropType2 = props[ 2 ];\n\t\t\tvar innerPropFlag = props[ 3 ];\n\t\t\tvar innerPropValue = props[ 4 ];\n\n\t\t\t// cast values where needed, otherwise leave as strings\n\t\t\tswitch ( innerPropType1 ) {\n\n\t\t\t\tcase 'int':\n\t\t\t\tcase 'enum':\n\t\t\t\tcase 'bool':\n\t\t\t\tcase 'ULongLong':\n\t\t\t\tcase 'double':\n\t\t\t\tcase 'Number':\n\t\t\t\tcase 'FieldOfView':\n\t\t\t\t\tinnerPropValue = parseFloat( innerPropValue );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'Color':\n\t\t\t\tcase 'ColorRGB':\n\t\t\t\tcase 'Vector3D':\n\t\t\t\tcase 'Lcl_Translation':\n\t\t\t\tcase 'Lcl_Rotation':\n\t\t\t\tcase 'Lcl_Scaling':\n\t\t\t\t\tinnerPropValue = parseNumberArray( innerPropValue );\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\t// CAUTION: these props must append to parent's parent\n\t\t\tthis.getPrevNode()[ innerPropName ] = {\n\n\t\t\t\t'type': innerPropType1,\n\t\t\t\t'type2': innerPropType2,\n\t\t\t\t'flag': innerPropFlag,\n\t\t\t\t'value': innerPropValue\n\n\t\t\t};\n\n\t\t\tthis.setCurrentProp( this.getPrevNode(), innerPropName );\n\n\t\t},\n\n\t} );\n\n\t// Parse an FBX file in Binary format\n\tfunction BinaryParser() {}\n\n\tObject.assign( BinaryParser.prototype, {\n\n\t\tparse: function ( buffer ) {\n\n\t\t\tvar reader = new BinaryReader( buffer );\n\t\t\treader.skip( 23 ); // skip magic 23 bytes\n\n\t\t\tvar version = reader.getUint32();\n\n\t\t\tconsole.log( 'THREE.FBXLoader: FBX binary version: ' + version );\n\n\t\t\tvar allNodes = new FBXTree();\n\n\t\t\twhile ( ! this.endOfContent( reader ) ) {\n\n\t\t\t\tvar node = this.parseNode( reader, version );\n\t\t\t\tif ( node !== null ) allNodes.add( node.name, node );\n\n\t\t\t}\n\n\t\t\treturn allNodes;\n\n\t\t},\n\n\t\t// Check if reader has reached the end of content.\n\t\tendOfContent: function ( reader ) {\n\n\t\t\t// footer size: 160bytes + 16-byte alignment padding\n\t\t\t// - 16bytes: magic\n\t\t\t// - padding til 16-byte alignment (at least 1byte?)\n\t\t\t//\t(seems like some exporters embed fixed 15 or 16bytes?)\n\t\t\t// - 4bytes: magic\n\t\t\t// - 4bytes: version\n\t\t\t// - 120bytes: zero\n\t\t\t// - 16bytes: magic\n\t\t\tif ( reader.size() % 16 === 0 ) {\n\n\t\t\t\treturn ( ( reader.getOffset() + 160 + 16 ) & ~ 0xf ) >= reader.size();\n\n\t\t\t} else {\n\n\t\t\t\treturn reader.getOffset() + 160 + 16 >= reader.size();\n\n\t\t\t}\n\n\t\t},\n\n\t\t// recursively parse nodes until the end of the file is reached\n\t\tparseNode: function ( reader, version ) {\n\n\t\t\tvar node = {};\n\n\t\t\t// The first three data sizes depends on version.\n\t\t\tvar endOffset = ( version >= 7500 ) ? reader.getUint64() : reader.getUint32();\n\t\t\tvar numProperties = ( version >= 7500 ) ? reader.getUint64() : reader.getUint32();\n\n\t\t\t// note: do not remove this even if you get a linter warning as it moves the buffer forward\n\t\t\tvar propertyListLen = ( version >= 7500 ) ? reader.getUint64() : reader.getUint32();\n\n\t\t\tvar nameLen = reader.getUint8();\n\t\t\tvar name = reader.getString( nameLen );\n\n\t\t\t// Regards this node as NULL-record if endOffset is zero\n\t\t\tif ( endOffset === 0 ) return null;\n\n\t\t\tvar propertyList = [];\n\n\t\t\tfor ( var i = 0; i < numProperties; i ++ ) {\n\n\t\t\t\tpropertyList.push( this.parseProperty( reader ) );\n\n\t\t\t}\n\n\t\t\t// Regards the first three elements in propertyList as id, attrName, and attrType\n\t\t\tvar id = propertyList.length > 0 ? propertyList[ 0 ] : '';\n\t\t\tvar attrName = propertyList.length > 1 ? propertyList[ 1 ] : '';\n\t\t\tvar attrType = propertyList.length > 2 ? propertyList[ 2 ] : '';\n\n\t\t\t// check if this node represents just a single property\n\t\t\t// like (name, 0) set or (name2, [0, 1, 2]) set of {name: 0, name2: [0, 1, 2]}\n\t\t\tnode.singleProperty = ( numProperties === 1 && reader.getOffset() === endOffset ) ? true : false;\n\n\t\t\twhile ( endOffset > reader.getOffset() ) {\n\n\t\t\t\tvar subNode = this.parseNode( reader, version );\n\n\t\t\t\tif ( subNode !== null ) this.parseSubNode( name, node, subNode );\n\n\t\t\t}\n\n\t\t\tnode.propertyList = propertyList; // raw property list used by parent\n\n\t\t\tif ( typeof id === 'number' ) node.id = id;\n\t\t\tif ( attrName !== '' ) node.attrName = attrName;\n\t\t\tif ( attrType !== '' ) node.attrType = attrType;\n\t\t\tif ( name !== '' ) node.name = name;\n\n\t\t\treturn node;\n\n\t\t},\n\n\t\tparseSubNode: function ( name, node, subNode ) {\n\n\t\t\t// special case: child node is single property\n\t\t\tif ( subNode.singleProperty === true ) {\n\n\t\t\t\tvar value = subNode.propertyList[ 0 ];\n\n\t\t\t\tif ( Array.isArray( value ) ) {\n\n\t\t\t\t\tnode[ subNode.name ] = subNode;\n\n\t\t\t\t\tsubNode.a = value;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tnode[ subNode.name ] = value;\n\n\t\t\t\t}\n\n\t\t\t} else if ( name === 'Connections' && subNode.name === 'C' ) {\n\n\t\t\t\tvar array = [];\n\n\t\t\t\tsubNode.propertyList.forEach( function ( property, i ) {\n\n\t\t\t\t\t// first Connection is FBX type (OO, OP, etc.). We'll discard these\n\t\t\t\t\tif ( i !== 0 ) array.push( property );\n\n\t\t\t\t} );\n\n\t\t\t\tif ( node.connections === undefined ) {\n\n\t\t\t\t\tnode.connections = [];\n\n\t\t\t\t}\n\n\t\t\t\tnode.connections.push( array );\n\n\t\t\t} else if ( subNode.name === 'Properties70' ) {\n\n\t\t\t\tvar keys = Object.keys( subNode );\n\n\t\t\t\tkeys.forEach( function ( key ) {\n\n\t\t\t\t\tnode[ key ] = subNode[ key ];\n\n\t\t\t\t} );\n\n\t\t\t} else if ( name === 'Properties70' && subNode.name === 'P' ) {\n\n\t\t\t\tvar innerPropName = subNode.propertyList[ 0 ];\n\t\t\t\tvar innerPropType1 = subNode.propertyList[ 1 ];\n\t\t\t\tvar innerPropType2 = subNode.propertyList[ 2 ];\n\t\t\t\tvar innerPropFlag = subNode.propertyList[ 3 ];\n\t\t\t\tvar innerPropValue;\n\n\t\t\t\tif ( innerPropName.indexOf( 'Lcl ' ) === 0 ) innerPropName = innerPropName.replace( 'Lcl ', 'Lcl_' );\n\t\t\t\tif ( innerPropType1.indexOf( 'Lcl ' ) === 0 ) innerPropType1 = innerPropType1.replace( 'Lcl ', 'Lcl_' );\n\n\t\t\t\tif ( innerPropType1 === 'Color' || innerPropType1 === 'ColorRGB' || innerPropType1 === 'Vector' || innerPropType1 === 'Vector3D' || innerPropType1.indexOf( 'Lcl_' ) === 0 ) {\n\n\t\t\t\t\tinnerPropValue = [\n\t\t\t\t\t\tsubNode.propertyList[ 4 ],\n\t\t\t\t\t\tsubNode.propertyList[ 5 ],\n\t\t\t\t\t\tsubNode.propertyList[ 6 ]\n\t\t\t\t\t];\n\n\t\t\t\t} else {\n\n\t\t\t\t\tinnerPropValue = subNode.propertyList[ 4 ];\n\n\t\t\t\t}\n\n\t\t\t\t// this will be copied to parent, see above\n\t\t\t\tnode[ innerPropName ] = {\n\n\t\t\t\t\t'type': innerPropType1,\n\t\t\t\t\t'type2': innerPropType2,\n\t\t\t\t\t'flag': innerPropFlag,\n\t\t\t\t\t'value': innerPropValue\n\n\t\t\t\t};\n\n\t\t\t} else if ( node[ subNode.name ] === undefined ) {\n\n\t\t\t\tif ( typeof subNode.id === 'number' ) {\n\n\t\t\t\t\tnode[ subNode.name ] = {};\n\t\t\t\t\tnode[ subNode.name ][ subNode.id ] = subNode;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tnode[ subNode.name ] = subNode;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tif ( subNode.name === 'PoseNode' ) {\n\n\t\t\t\t\tif ( ! Array.isArray( node[ subNode.name ] ) ) {\n\n\t\t\t\t\t\tnode[ subNode.name ] = [ node[ subNode.name ] ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\tnode[ subNode.name ].push( subNode );\n\n\t\t\t\t} else if ( node[ subNode.name ][ subNode.id ] === undefined ) {\n\n\t\t\t\t\tnode[ subNode.name ][ subNode.id ] = subNode;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t},\n\n\t\tparseProperty: function ( reader ) {\n\n\t\t\tvar type = reader.getString( 1 );\n\n\t\t\tswitch ( type ) {\n\n\t\t\t\tcase 'C':\n\t\t\t\t\treturn reader.getBoolean();\n\n\t\t\t\tcase 'D':\n\t\t\t\t\treturn reader.getFloat64();\n\n\t\t\t\tcase 'F':\n\t\t\t\t\treturn reader.getFloat32();\n\n\t\t\t\tcase 'I':\n\t\t\t\t\treturn reader.getInt32();\n\n\t\t\t\tcase 'L':\n\t\t\t\t\treturn reader.getInt64();\n\n\t\t\t\tcase 'R':\n\t\t\t\t\tvar length = reader.getUint32();\n\t\t\t\t\treturn reader.getArrayBuffer( length );\n\n\t\t\t\tcase 'S':\n\t\t\t\t\tvar length = reader.getUint32();\n\t\t\t\t\treturn reader.getString( length );\n\n\t\t\t\tcase 'Y':\n\t\t\t\t\treturn reader.getInt16();\n\n\t\t\t\tcase 'b':\n\t\t\t\tcase 'c':\n\t\t\t\tcase 'd':\n\t\t\t\tcase 'f':\n\t\t\t\tcase 'i':\n\t\t\t\tcase 'l':\n\n\t\t\t\t\tvar arrayLength = reader.getUint32();\n\t\t\t\t\tvar encoding = reader.getUint32(); // 0: non-compressed, 1: compressed\n\t\t\t\t\tvar compressedLength = reader.getUint32();\n\n\t\t\t\t\tif ( encoding === 0 ) {\n\n\t\t\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\t\t\tcase 'b':\n\t\t\t\t\t\t\tcase 'c':\n\t\t\t\t\t\t\t\treturn reader.getBooleanArray( arrayLength );\n\n\t\t\t\t\t\t\tcase 'd':\n\t\t\t\t\t\t\t\treturn reader.getFloat64Array( arrayLength );\n\n\t\t\t\t\t\t\tcase 'f':\n\t\t\t\t\t\t\t\treturn reader.getFloat32Array( arrayLength );\n\n\t\t\t\t\t\t\tcase 'i':\n\t\t\t\t\t\t\t\treturn reader.getInt32Array( arrayLength );\n\n\t\t\t\t\t\t\tcase 'l':\n\t\t\t\t\t\t\t\treturn reader.getInt64Array( arrayLength );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t\n\t\t\t\t\tvar inflate = new Zlib.Inflate( new Uint8Array( reader.getArrayBuffer( compressedLength ) ) ); // eslint-disable-line no-undef\n\t\t\t\t\tvar reader2 = new BinaryReader( inflate.decompress().buffer );\n\n\t\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\t\tcase 'b':\n\t\t\t\t\t\tcase 'c':\n\t\t\t\t\t\t\treturn reader2.getBooleanArray( arrayLength );\n\n\t\t\t\t\t\tcase 'd':\n\t\t\t\t\t\t\treturn reader2.getFloat64Array( arrayLength );\n\n\t\t\t\t\t\tcase 'f':\n\t\t\t\t\t\t\treturn reader2.getFloat32Array( arrayLength );\n\n\t\t\t\t\t\tcase 'i':\n\t\t\t\t\t\t\treturn reader2.getInt32Array( arrayLength );\n\n\t\t\t\t\t\tcase 'l':\n\t\t\t\t\t\t\treturn reader2.getInt64Array( arrayLength );\n\n\t\t\t\t\t}\n\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error( 'THREE.FBXLoader: Unknown property type ' + type );\n\n\t\t\t}\n\n\t\t}\n\n\t} );\n\n\n\tfunction BinaryReader( buffer, littleEndian ) {\n\n\t\tthis.dv = new DataView( buffer );\n\t\tthis.offset = 0;\n\t\tthis.littleEndian = ( littleEndian !== undefined ) ? littleEndian : true;\n\n\t}\n\n\tObject.assign( BinaryReader.prototype, {\n\n\t\tgetOffset: function () {\n\n\t\t\treturn this.offset;\n\n\t\t},\n\n\t\tsize: function () {\n\n\t\t\treturn this.dv.buffer.byteLength;\n\n\t\t},\n\n\t\tskip: function ( length ) {\n\n\t\t\tthis.offset += length;\n\n\t\t},\n\n\t\t// seems like true/false representation depends on exporter.\n\t\t// true: 1 or 'Y'(=0x59), false: 0 or 'T'(=0x54)\n\t\t// then sees LSB.\n\t\tgetBoolean: function () {\n\n\t\t\treturn ( this.getUint8() & 1 ) === 1;\n\n\t\t},\n\n\t\tgetBooleanArray: function ( size ) {\n\n\t\t\tvar a = [];\n\n\t\t\tfor ( var i = 0; i < size; i ++ ) {\n\n\t\t\t\ta.push( this.getBoolean() );\n\n\t\t\t}\n\n\t\t\treturn a;\n\n\t\t},\n\n\t\tgetUint8: function () {\n\n\t\t\tvar value = this.dv.getUint8( this.offset );\n\t\t\tthis.offset += 1;\n\t\t\treturn value;\n\n\t\t},\n\n\t\tgetInt16: function () {\n\n\t\t\tvar value = this.dv.getInt16( this.offset, this.littleEndian );\n\t\t\tthis.offset += 2;\n\t\t\treturn value;\n\n\t\t},\n\n\t\tgetInt32: function () {\n\n\t\t\tvar value = this.dv.getInt32( this.offset, this.littleEndian );\n\t\t\tthis.offset += 4;\n\t\t\treturn value;\n\n\t\t},\n\n\t\tgetInt32Array: function ( size ) {\n\n\t\t\tvar a = [];\n\n\t\t\tfor ( var i = 0; i < size; i ++ ) {\n\n\t\t\t\ta.push( this.getInt32() );\n\n\t\t\t}\n\n\t\t\treturn a;\n\n\t\t},\n\n\t\tgetUint32: function () {\n\n\t\t\tvar value = this.dv.getUint32( this.offset, this.littleEndian );\n\t\t\tthis.offset += 4;\n\t\t\treturn value;\n\n\t\t},\n\n\t\t// JavaScript doesn't support 64-bit integer so calculate this here\n\t\t// 1 << 32 will return 1 so using multiply operation instead here.\n\t\t// There's a possibility that this method returns wrong value if the value\n\t\t// is out of the range between Number.MAX_SAFE_INTEGER and Number.MIN_SAFE_INTEGER.\n\t\t// TODO: safely handle 64-bit integer\n\t\tgetInt64: function () {\n\n\t\t\tvar low, high;\n\n\t\t\tif ( this.littleEndian ) {\n\n\t\t\t\tlow = this.getUint32();\n\t\t\t\thigh = this.getUint32();\n\n\t\t\t} else {\n\n\t\t\t\thigh = this.getUint32();\n\t\t\t\tlow = this.getUint32();\n\n\t\t\t}\n\n\t\t\t// calculate negative value\n\t\t\tif ( high & 0x80000000 ) {\n\n\t\t\t\thigh = ~ high & 0xFFFFFFFF;\n\t\t\t\tlow = ~ low & 0xFFFFFFFF;\n\n\t\t\t\tif ( low === 0xFFFFFFFF ) high = ( high + 1 ) & 0xFFFFFFFF;\n\n\t\t\t\tlow = ( low + 1 ) & 0xFFFFFFFF;\n\n\t\t\t\treturn - ( high * 0x100000000 + low );\n\n\t\t\t}\n\n\t\t\treturn high * 0x100000000 + low;\n\n\t\t},\n\n\t\tgetInt64Array: function ( size ) {\n\n\t\t\tvar a = [];\n\n\t\t\tfor ( var i = 0; i < size; i ++ ) {\n\n\t\t\t\ta.push( this.getInt64() );\n\n\t\t\t}\n\n\t\t\treturn a;\n\n\t\t},\n\n\t\t// Note: see getInt64() comment\n\t\tgetUint64: function () {\n\n\t\t\tvar low, high;\n\n\t\t\tif ( this.littleEndian ) {\n\n\t\t\t\tlow = this.getUint32();\n\t\t\t\thigh = this.getUint32();\n\n\t\t\t} else {\n\n\t\t\t\thigh = this.getUint32();\n\t\t\t\tlow = this.getUint32();\n\n\t\t\t}\n\n\t\t\treturn high * 0x100000000 + low;\n\n\t\t},\n\n\t\tgetFloat32: function () {\n\n\t\t\tvar value = this.dv.getFloat32( this.offset, this.littleEndian );\n\t\t\tthis.offset += 4;\n\t\t\treturn value;\n\n\t\t},\n\n\t\tgetFloat32Array: function ( size ) {\n\n\t\t\tvar a = [];\n\n\t\t\tfor ( var i = 0; i < size; i ++ ) {\n\n\t\t\t\ta.push( this.getFloat32() );\n\n\t\t\t}\n\n\t\t\treturn a;\n\n\t\t},\n\n\t\tgetFloat64: function () {\n\n\t\t\tvar value = this.dv.getFloat64( this.offset, this.littleEndian );\n\t\t\tthis.offset += 8;\n\t\t\treturn value;\n\n\t\t},\n\n\t\tgetFloat64Array: function ( size ) {\n\n\t\t\tvar a = [];\n\n\t\t\tfor ( var i = 0; i < size; i ++ ) {\n\n\t\t\t\ta.push( this.getFloat64() );\n\n\t\t\t}\n\n\t\t\treturn a;\n\n\t\t},\n\n\t\tgetArrayBuffer: function ( size ) {\n\n\t\t\tvar value = this.dv.buffer.slice( this.offset, this.offset + size );\n\t\t\tthis.offset += size;\n\t\t\treturn value;\n\n\t\t},\n\n\t\tgetString: function ( size ) {\n\n\t\t\tvar a = new Uint8Array( size );\n\n\t\t\tfor ( var i = 0; i < size; i ++ ) {\n\n\t\t\t\ta[ i ] = this.getUint8();\n\n\t\t\t}\n\n\t\t\tvar nullByte = a.indexOf( 0 );\n\t\t\tif ( nullByte >= 0 ) a = a.slice( 0, nullByte );\n\n\t\t\treturn THREE.LoaderUtils.decodeText( a );\n\n\t\t}\n\n\t} );\n\n\t// FBXTree holds a representation of the FBX data, returned by the TextParser ( FBX ASCII format)\n\t// and BinaryParser( FBX Binary format)\n\tfunction FBXTree() {}\n\n\tObject.assign( FBXTree.prototype, {\n\n\t\tadd: function ( key, val ) {\n\n\t\t\tthis[ key ] = val;\n\n\t\t},\n\n\t} );\n\n\tfunction isFbxFormatBinary( buffer ) {\n\n\t\tvar CORRECT = 'Kaydara FBX Binary  \\0';\n\n\t\treturn buffer.byteLength >= CORRECT.length && CORRECT === convertArrayBufferToString( buffer, 0, CORRECT.length );\n\n\t}\n\n\tfunction isFbxFormatASCII( text ) {\n\n\t\tvar CORRECT = [ 'K', 'a', 'y', 'd', 'a', 'r', 'a', '\\\\', 'F', 'B', 'X', '\\\\', 'B', 'i', 'n', 'a', 'r', 'y', '\\\\', '\\\\' ];\n\n\t\tvar cursor = 0;\n\n\t\tfunction read( offset ) {\n\n\t\t\tvar result = text[ offset - 1 ];\n\t\t\ttext = text.slice( cursor + offset );\n\t\t\tcursor ++;\n\t\t\treturn result;\n\n\t\t}\n\n\t\tfor ( var i = 0; i < CORRECT.length; ++ i ) {\n\n\t\t\tvar num = read( 1 );\n\t\t\tif ( num === CORRECT[ i ] ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\tfunction getFbxVersion( text ) {\n\n\t\tvar versionRegExp = /FBXVersion: (\\d+)/;\n\t\tvar match = text.match( versionRegExp );\n\t\tif ( match ) {\n\n\t\t\tvar version = parseInt( match[ 1 ] );\n\t\t\treturn version;\n\n\t\t}\n\t\tthrow new Error( 'THREE.FBXLoader: Cannot find the version number for the file given.' );\n\n\t}\n\n\t// Converts FBX ticks into real time seconds.\n\tfunction convertFBXTimeToSeconds( time ) {\n\n\t\treturn time / 46186158000;\n\n\t}\n\n\n\t// Parses comma separated list of numbers and returns them an array.\n\t// Used internally by the TextParser\n\tfunction parseNumberArray( value ) {\n\n\t\tvar array = value.split( ',' ).map( function ( val ) {\n\n\t\t\treturn parseFloat( val );\n\n\t\t} );\n\n\t\treturn array;\n\n\t}\n\n\tfunction convertArrayBufferToString( buffer, from, to ) {\n\n\t\tif ( from === undefined ) from = 0;\n\t\tif ( to === undefined ) to = buffer.byteLength;\n\n\t\treturn THREE.LoaderUtils.decodeText( new Uint8Array( buffer, from, to ) );\n\n\t}\n\n\tfunction append( a, b ) {\n\n\t\tfor ( var i = 0, j = a.length, l = b.length; i < l; i ++, j ++ ) {\n\n\t\t\ta[ j ] = b[ i ];\n\n\t\t}\n\n\t}\n\n\tfunction slice( a, b, from, to ) {\n\n\t\tfor ( var i = from, j = 0; i < to; i ++, j ++ ) {\n\n\t\t\ta[ j ] = b[ i ];\n\n\t\t}\n\n\t\treturn a;\n\n\t}\n\n\t// inject array a2 into array a1 at index\n\tfunction inject( a1, index, a2 ) {\n\n\t\treturn a1.slice( 0, index ).concat( a2 ).concat( a1.slice( index ) );\n\n\t}\n\n\treturn THREE.FBXLoader\n\n} )();\n"],"sourceRoot":""}